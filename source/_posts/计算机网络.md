---
title: 计算机网络
date: 2019-11-23 17:34:33
tags: 网络
---

计算机网络笔记 - 自顶向下的方法

<!-- more -->

# 计算机网络和因特网

## 网络核心

### 分组交换

​ 一般而言，从源端系统向目的端发送一个报文, 源将长报文划分为较小的数据块, 称之为分组, 在源和目的地之间, 每个分组都通过通信链路和`分组交换机`传送. (交换机主要有两类: `路由器`和`链路层交换机`).

> ​ 分组以等于该链路`最大`传输速率的速度传输通过电信链路,因此如果某源端系统或分组交换机经过一条链路发送一个 L 比特的分组, 链路的传输速率为 R bit/s, 则传输该分组的时间为 L/R s.

### 排队延时和分组丢失

​ 对于每条相连的链路,该分组交换机具有一个`输出缓存`(也称输出队列), 因此当该链路忙于传送其他分组, 该分组必须在输出缓存中`等待`. 因此除了转发延时, 分组还要承受数据缓存的`排队时延`, 时延是变化的, 主要取决网络拥堵的程度, 又因为缓存空间有限, 当缓存空间使用完毕, 将出`分组丢失`也就是`丢包` ,到达的分组或已经排队的分组之一将被丢弃.

### 转发表和路有选择协议

​ 在因特网中,每个端系统具有一个被称为 IP 地址的地址, 当源主机箱目的端系统发送一个分组时, 源在该分组的首部包含了`目的地的 IP 地址`, 当一份到达网络中的路由器时, 路由器检查该分组的目的地的`一部分`并向一台相邻的路由器转发该地址, 每台路由器具有一个`转发表`,用于将目的地址(护着地址的一部分) 映射称为输出链路. 路由器会检查分组的地址, 并使用转发表将分组导向到适当的链路中.

### 电路交换

​ 通过网络链路和交换机移动数据有两种基本方法: `电路交换`和`分组交换`.

​ 在电路交换网络中,在端系统通信会话期间,`预留了`端系统间沿路径通信所需要的资源(缓存,链路传输速率), 而在分组交换网络中, 这些资源则`不是预留的`, 会话的报文按需使用这些资源, 其后果可能是不得不等待接入通信线路.

电路交换网络中的复用

​ 链路中的电路通过`频分复用`(Frequency-Division Multilexing, FDM)或`时分复用`(Time-Division Multiplexing, TDM)来实现, 对于 FDM, 链路的频谱由跨越链路创建的所有连接共享, 在连接器件链路为每条连接专用一个频段,例如在一条链路中电话通常是 4kHz, 而调频无线电通常为 88 - 108kHZ 的频谱, 其中每个电台被分配一个特定的频段.

​ 而对于 TDM 链路,时间被分为固定期间的帧, 并且每个帧又被划分为固定数量的间隙,当网络跨越一条链路创建一条连接时, 网络在每个帧中为该链接制定一个间隙. 这些间隙专门由该链接单独使用, 一个时隙(在每个帧内)可以用于传输该链接的数据.

分组交换和电路交换的区别:

- 分组交换可能会有不可预测的延迟,而电路交换则是固定的
- 分组交换可以更高效的利用宽带,而且他比电路交换简单有效实现成本更低,而电路交换则更好相反

### 分组交换网中的时延,丢包和吞吐量

​ 分组从一台主机(源)出发, 通过一系列路由器传输, 在另一台主机(目的地)中结束他的历程. 当分组从一个节点(主机或者路由器)沿着这条路径到达后续节点(主机或者路由器), 该分组在沿途的每个节点经受了几种不同类型的时延, 其中最重要的是以下集中时延:

- 节点处理时延

- 排队时延

- 传输时延

- 传播时延

  以上时延相加结果就是节点总时延

### 时延的类型

1. 处理时延

   ​ 检查分组首部和决定该分组导向何处所需要的时间是`处理时延`的一部分. 高速路由器的处理时延通常是微秒或者更低的数量级.

2. 排队时延

   ​ 在队列中,当分组在链路上传输时, 它经受`排队时延`, 分组的排队时延取决于链路中等待传输的分组数量,如果队列是空的则时延为 0, 如果流量很大,则该队列会很长, 时延将会变长, 实际的排队时延可以是毫秒级到微秒级.

3. 传输时延

   ​ 嘉定分组以先到先服务方式传输----这在分组交换机中是常见的额方式, 仅当所有已经到达的分组被传输后, 才能传输刚到达的分组. 例如对于一条 10Mbps 的以太网链路, 速率是 R=10Mbps,`传输延时`是 L/R, L 是该分组的长度.实际的传输时延通常在毫秒到微秒量级

4. 传播时延

   ​ 一旦一个 bit 被推向链路, 该比特需要向路由器 B 传播, 从该链路的起点到路由器 B 传播所需要的时间就是`传播时延`. 这取决于传播链路的物理媒介, 在广域网中, 传播时延通常为毫秒量级.

5. 传输时延和传播时延的比较

   ​ 两者的差异是微秒而重要的, 传输时延是路由器推出分组所需要的时间, 他是分组长度和链路传输速率的函数,而与两台路由器之间的距离无关, 而传播时延是一个 bit 从一台路由器传播到另一台路由器所需要的时间,他是两个路由器之间距离的函数, 而与分组长度或链路传输速率无关.

### 协议分层

​ 因特网的协议栈有五个层次组成: `物理层` `链路层` `网络层` `传输层` `应用层`

#### 应用层

​ 应用层是网络应用程序及他们的应用层协议存留的地方,因特网的应用层有很多协议,例如 HTTP SMTP FTP 等,还有域名系统 DNS.

​ 应用层协议分布在多个端系统上,从一个段系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组, 这种位于应用层信息分组称为报文.

#### 运输层

​ 英特网的运输层在应用程序之间传送应用层报文, 在英特网中,有两种运输协议, 即 TCP 和 UDP , TCP 向它的应用层提供了面向连接的服务,这种服务包括了应用层报文向目的地的确保传递和流量控制, TCP 也将长报文分为短报文,并提供拥塞控制机制,因此当网络拥塞是,源一致其传输速率, 而 UDP 协议向他的应用程序提供无连接服务,这一种不提供不必要服务的服务, 没有可靠性, 没有流量控制,也没有拥塞控制.

#### 网络层

​ 因特网的网络层负责将称为`数据报`的网络层从分组从一台主机移动到另一台主机,

#### 链路层

​ 因特网的网络层通过源和目的地之间的一系列路由器路由数据报,为了将分组从一个节点(主机或路由器)移动到路径的下一个节点,网络层必须依靠该链路层的服务.特别是在每个节点,网络层将数据报下传给链路层,链路层沿着路径将数据报传给下一个节点,在该下一个节点,链路层将数据报上传给网络层.

#### 物理层

​ 物理层的任务是将该帧中的一个个 bit 从一个节点移动到下一个节点.在这层中的协议仍然链路层相关的,并且进一步与该链路(传输介质)的实际参数媒体相关.

# 应用层

## 应用层协议原理

### 进程与计算机网络之间的接口

​ 多数应用程序是由通信进程对组成,每对中的两个进程互相发送报文. 从一个进程向另一个进程发送的报文必须通过下面的网络, 进程通过一个称为`套接字`的软件接口向网络发送报文和从网络接受报文.

> 套接字是同一台主机内应用层与传输层之间的接口,由于该套接字是建立网络应用程序的可编程接口, 因此套接字(socket)也被称为应用程序和网络之间的`应用程序编程接口(Application Programma Interface, API)`.

​ 应用程序开发者可以控制套接字在应用端的一切, 但是对于该套接字的运输层几乎没有控制权, 应用程序开发者对于运输层的控制仅限于:

1. 选择运输层协议
2. 也许能设定几个运输层参数,如最大缓存和最大报文段长度等

一旦应用程序开发者选择了一个运输层协议(如果可供选择的话),则应用程序就建立在由该协议提供的运输服务之上.

### 进程寻址

​ 例如在想特定目的地发送向邮政邮件, 目的地需要有一个地址,类似的,在一台主机运行的进程向在另一台主机上运行的进程发送分组, 接受进程需要有一个地址,为了标识该接受进程,需要定义两个信息, 主机的地址以及在目的主机中指定接受进程的标识符.

​ 而在因特网中,主机由其`IP地址`标识,一般而言发送进程还必须指定运行在接收主机上的接收进程,因为一般而言一台主机能够运行许多网络应用,而目的地的`端口号`则用于这个目的,已经给流行的应用分配了特定的端口号,例如 Web 服务使用 80 来标识,邮件服务使用 25 标识.

###可用应用程序使用的运输服务

​ 包括因特网在内的许多网络提供了不止一种运输协议,开发一个应用时必须选择一个可用的运输协议,对于不同的运输协议大体可以通过一下四种进行分类: `可靠数据传输` `吞吐量` `定时` 和 `安全性`

#### 可靠数据传输

​ 分组在计算机中可能丢失,例如丢包,但是对于某些应用,例如银行系统,分组丢失会导致灾难性后果,因此为了支持这些应用,必须做一些工作由应用程序的一段发送的数据正确和完整的交付给该应用程序的另一端, 如果一个协议提供了这样的确保数据交付的服务,就认为提供了`可靠数据传输`,运输层协议能够潜在的向应用程序提供的一个重要服务是进程到进程的可靠数据传输. 当一个运输协议提供这种服务时,发送进程只需要将其数据传递进套接字,就可以完全相信该数据将能无差错地到达接受进程.

​ 当一个运输层协议不提供可靠数据传输时, 由发送进程发送的某些数据可能达到不了接收进程,这可能能被`容忍丢失的应用`所接受,如视频,音频应用中丢失部分数据会出现小干扰,而不是致命的损伤

#### 吞吐量

​ 可用吞吐量就是发送进程能够像接收进程交付 bit 的速率,因为其他会话将功效沿着该网络路径的宽带,并且因为该到达和离开,该可用吞吐量会随时间波动,具有吞吐量要求的应用程序被成为`宽带敏感的应用`,宽带明爱的应用具有特定的吞吐量要求, 而`弹性应用`能够根据当时可用的宽带或多或少的利用可用使用的吞吐量, 例如电子邮件,文件传输,Web 传送都属于弹性应用.

#### 定时

​ 运输层协议也能提供定时保证,如同具有吞吐量那样的保证,例如保证发送方注入套接字中的 bit 不迟于 100ms 到达接收方.

#### 安全性

​ 运输协议能够为应用程序提供一种或者多种安全性服务,例如在发送主机中,运输协议能够加密发送进程传输中的所有数据,在接收主机中,运输协议能够在将书记交付给接收进程之前解密这些数据.

### 因特网提供的运输服务

​ 因特网(更一般的是 TCP/IP 网络)为应用程序提供了两个运输协议,即 UDP 和 TCP, 所以当为英特网提供一个新的应用程序时,首先要考虑的决定是: 使用 UDP 还是 TCP , 每个协议为调用他们的应用程序提供了不同的服务集合

#### TCP

​ TCP 服务模型包括面向连接服务和可靠数据传输服务, 当某个程序调用 TCP 作为其运输协议时, 该应用程序就能获得来自 TCP 的这种服务.

1. 面向连接的服务

​ 在应用层数据报文开始流动之前, TCP 让客户和服务器互相交换运输层控制信息, 这个所谓的握手过程是提醒客户和服务器,让他们为大量分组的到来做好准备, 在握手阶段后,一个 TCP 连接就在两个进程的套接字之间建立,这条连接时双工的,即连接的双发的进程可以在此连接上同事进行报文手法,当应用程序结束报文发送时,必须拆除该连接.

2. 可靠的数据传送服务

   通信能够依靠 TCP,无差错并且按照适当的顺序交付所发送的数据,当应用程序的一段将字节流传进套接字时,它

能够依靠 TCP 将相同的字节流交付给接收方的套接字,而没有字节的丢失和冗余.

​ TCP 协议还具有拥塞控制机制,这种服务并不一定能为通信进程带来直接的好处,但能为因特尔网络带来整体的好处,当发送放和接收方网络出现拥塞时, TCP 的拥塞控制会一致发送进程. TCP 拥塞控制也试图限制每个 TCP 连接,使他们达到公平共享网络宽带的目的.

#### UDP

​ UDP 是一种不提供不必要服务的轻量级运输协议, 它仅提供最小服务, UDP 是无连接的, 因此在两个进程通信前是没有握手过程的, UDP 协议提供一种不可靠数据传送服务, 当进程讲一个报文发送进 UDP 套接字时, UDP 协议并不保证该报文将到达接收进程,而且到达接收进程的报文也可能是乱序到达的.

### 应用层协议

​ `应用层协议`定义了运行在不同端系统上的应用程序进程如何相互传递报文. 特别是应用层协议定义了:

1. 交换的报文类型,比如请求报文和响应报文
2. 各种报文类型的语法, 如报文中的各个字段以及这些字段是如何描述的
3. 字段的语义,即这些字段中的信息的含义
4. 确定一个进程何时如何发送报文,对报文进行响应的规则

​ Web 的应用层协议时 HTTP, 它定义了浏览器和 Web 服务器之间传输的报文格式和序列,因此, HTTP 只是 Web 的一个部分,尽管是一个重要的部分,又例如邮件系统的应用层协议就是 SMTP(简单邮件传输协议),因此邮件的首要应用层协议 SMTP 也只是电子邮件应用的一个部分.

### Web 和 HTTP

#### HTTP 概况

​ Web 的应用层协议是`超文本传输协议`(HyperText Transfer Protocol, HTTP), 它是 Web 的核心, HTTP 由两个程序实现: 一个客户程序和一个服务器程序. 客户程序和服务程序运行在不同的端系统中,通过交换 HTTP 报文进行会话,HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的地方. 客户想他的套接字接口发送和接收 HTTP 报文,一旦客户向他的套接字接口发送了一个请求报文,这个报文就脱离了客户端控制并且进入 TCP 控制, 而 TCP 为 HTTP 提供可靠的数据传输服务.

#### 非持续连接和持续连接

​ 在许多因特网应用程序中,客户和服务器在一个想当长的时间范围内通信,其中客户发出一系列请求并且服务器对每个请求进行相应,客户-服务器交互式通过 TCP 进行的,那么程序的研制者就要做出一个重要的决定,即每个请求/响应式经单独的 TCP 进行还是所有的请求和响应通过相同的 TCP 连接发送,采用前一种方法,该应用程序被称为使用`非持续连接`采用后一种方法,该应用程序被称为使用`持续连接`

#### 采用非持续连接的 HTTP

​ 当采用非持续连接情况下,服务器向客户端发送一个 Web 页面的步骤:

1. HTTP 客户进程在 80 端口发起一个到服务器的 TCP 连接
2. HTTP 客户经他的套接字向该服务器发送一个 HTTP 请求报文,报文中包含了所需要的资源
3. HTTP 服务器进程经他的套接字接收到该请求报文,并在一个 HTTP 响应报文中封装对象,并通过其套接字向客户发送响应报文
4. HTTP 服务器进程通知 TCP 断开该 TCP 连接(但是直到 TCP 确认客户已经完整的收到响应报文,它才会实际中段连接)
5. HTTP 客户收到响应报文, TCP 连接关闭, 并解析报文,从中读取资源或者资源地址,对于地址重复以上步骤得到资源.

​ 上面步骤说明了非持续连接的使用,其中每个 TCP 连接在服务器发送一个对象后关闭,该链接并不为其他的对象而持续下来.

​ 浏览器和 Web 服务器之间发起一个 TCP 连接,涉及一次"三次握手"过程,即客户想服务器发送一个小 TCP 报文,服务器用一个小的 TCP 报文做出确认响应,最后客户想服务器返回确认, 三次握手中前两部分所消耗的时间占用一个`往返时间`,完成三次握手的前两部分后,客户结合三次握手的第三部分(确认)向该 TCP 链接发送一个 HTTP 请求报文,一旦该请求报文送达服务器,服务器就在该 TCP 连接上发送响应,该 HTTP 请求/响应用去了另一个`往返时间`因此粗略讲总的响应时间就是两个`往返时间`加上服务器传输 HTML 文件的时间.

#### 采用持续的 HTTP

​ 非持续连接的缺点:

1. 必须为*每一个请求的对象*建立和维护一个全新的连接,对于每个这样的连接,在客户和服务中都要分配 TCP 的缓冲区和保持 TCP 变量,这给服务器带来了严重的负担.
2. 每一个对象需要经受双倍的`往返时间`即一个用于创建 TCP 的往返时间,一个用户请求和接收一个对象的往返时间

在采用 HTTP1.1 持续连接的情况下服务器在发送响应后保持该 TCP 连接打开,在相同的客户与服务器之间,后续的请求和报文能够通过相同的连接进行传输, 这样可以节省资源和加快响应时间.一般来说一条连接经过一定时间间隔(可配置的间隔)仍未被使用, HTTP 服务器就关闭该连接,HTTP 的默认模式是使用带流水线的持续连接, HTTP/2 是子 HTTP1.1 基础上构建的,他允许在相同的连接中多个请求和回答交错,并增加了该连接中优化 HTTP 报文请求和回答机制.

#### HTTP 报文格式

​ HTTP 规范包含对 HTTP 格式的定义,HTTP 报文有两种:`请求报文`和`响应报文`

    	>```html
    	>// 请求报文
    	>GET / HTTP/1.1
    	>Host: developer.mozilla.org
    	>Accept-Language: fr
    	>```

​ 报文使用普通的 ASCII 文本, 又若干行组成,每一行由一个回车和换行符结束,最后一行在附加一个回车换行符.

HTTP 请求报文的第一行叫做`请求行`后继的行叫做`首部行`请求航有三个字段:`方法字段` `URL` 和 `HTTP版本`字段

> ```html
> // 响应报文
> HTTP/1.1 200 OK
> Date: Sat, 09 Oct 2010 14:28:02 GMT
> Server: Apache
> Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
> ETag: "51142bc1-7449-479b075b2891b"
> Accept-Ranges: bytes
> Content-Length: 29769
> Content-Type: text/html
>
> <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
> ```

​ 想一个报文包含三个部分: 一个初始`状态行`, 若干`首部行`然后是`实体体`

#### cookie

​ HTTP 是无状态的,这简化了服务器的设计,HTTP 中使用了 cookie,来对用户进行追踪,识别以及限制.

#### Web 缓存

​ Web 缓存(Web cache) 也叫代理服务器,它能代表初始 Web 服务器来满足 HTTP 请求的网络实体.Web 缓存器有自己的磁盘储存空间,并且在存储空间中保存最近请求过的对象的副本.在因特网中部署 Web 缓存浏览器有两个原因,首先 Web 缓存器可以大大减少对客户请求的响应时间,Web 缓存器能从整体上大大降低因特网上的 Web 流量,从而改善所有应用的性能.

### 英特网中的电子邮件

#### SMTP

​ SMTP(Simple Mail Transfer Protocol, SMTP), 是电子邮件中的主要应用协议, 它使用 TCP 可靠数据传输, SMTP 问世的时间比 HTTP 要长的多, 一般而言 SMTP 不适用中间邮件服务器发送邮件,及时这两个服务器位于地球的两端.

​ HTTP 协议和 SMTP 协议中药的一些区别, HTTP 通常是从服务器上拉取数据,而 SMTP 通常是通常是推数据,SMTP 要求每个报文(包括他们的体)采用 7bit ASCII 码格式,如果报文包含了非 7bit ASCII 字符 或者二进制数据,则该报文必须按照 7bit ASCII 码进行编码, HTTP 则不收这种限制, 对于一个既包含文本又包含图形(或者其他媒体)的文档,HTTP 吧每个对象封装到他自己的 HTTP 响应报文中,而 SMTP 则吧所有对象放在一个报文中.

#### POP3

​ POP3 是一种极为简单的邮件访问协议,简短并且可读性强, 因为协议简单,故功能业有限,当用户打开了一个到邮件服务端口 110 上的 TCP 连接后, POP3 就开始工作了, 随着 TCP 连接, POP3 按照三个阶段进行工作, `特许` `事务处理` `更新`, 在特许结局单,用户代理发送明文用户名和口令鉴别用户, 事务处理阶段,用户取回报文, 同事在这个阶段用户还能做如下操作: 对报文做删除标记, 取消报文删除标记,以及获取邮件的统计信息. 在更新阶段, 他出现在客户发出了 quit 命令之后, 目的是结束该 POP3 会话,这时邮件服务器应该删除那些被标记为删除的报文.

#### IMAP

​ 使用 POP3 访问时,一旦邮件下载到本级后,就可以建立邮件文件夹,并将下载的邮件放入文件夹中,并且可以操作这些文件夹,但是用户可能更喜欢使用一个在远程服务器上的层次文件夹, 使用 POP3 是不可能做到这一点的, POP3 协议没有给 yoghurt 提供任何创建远程文件夹并为报文指派文件夹的方法,

​ 为了解决这些问题, IMAP 邮件访问协议诞生了, 和 POP3 一样,IMAP 是邮件访问协议,但是他比 POP3 具有更多特色,并且也比 POP3 复杂的多(客户端和服务端实现都比 POP3 复杂)

​ IMAP 服务器把每个报文和文件夹联系起来,当报文第一次到达服务器是,它与收件人的 INBOC 文件夹关联,收件人则能吧邮件移动到一个新的,用户创建的文件夹中,阅读邮件,删除邮件等.

### DNS: 因特网的目录服务

​ 在英特网中,主机和人类一样,可以使用多种方式进行标识,主机表示法是使用它的`主机名`,然而主机名技术没有提供关于主机在英特网中的位置信息,所以主机也可以使用所谓的`IP地址`进行标识.

#### DNS 提供的服务

​ 人类对名称比较敏感,也便于记忆,而机器更喜欢定长的有层次结构的 IP 地址,为了折中这些不同的偏好,需要一种能进行主机名到 IP 地址转换的目录服务,这就是`域名系统(Domain Name System, DNS)`的主要任务

​ DNS 是:

1. 一个由分层的 DNS 服务器实现的分布式数据库
2. 一个使得主机能够查询分布式数据库的应用层协议,DNS 服务器通常是运行 BIND(Berkeley Internet Name Domain) 软件的 UNIX 机器, DNS 协议运行在 `UDP` 之上 使用 53 端口

​ DNS 通常是由其他应用层协议所使用, 包括 HTTP SMTP FTP 等, 将用户提供的主机名解析成一个 IP 地址.大体流程如下:

1. 浏览器从 UTL 中抽取主机名,并将这个主机名传给 DNS 应用的客户端
2. DNS 客户向 DNS 服务器发送一个包含主机名的请求
3. DNS 客户最终后收到一份回答报文,其中含有对应于该主机名的 IP 地址
4. 一旦浏览器收到来自 DNS 的该 IP 地址,它能够向位于 IP 地址 80 端口的 HTTP 服务器进程发起一个 TCP

​ 从例子中可以看到 DNS 给其他的应用带肋了额外的延迟,并且有时延时还相当可观,幸运的是,通常 IP 地址通常就缓存在一个"附近"的 DNS 服务器中,这有助于减少 DNS 的网络流量和 DNS 的平均延迟.

​

​ 除了进行主机名到 IP 地址的转换之外,DNS 还提供一些重要服务:

1. 主机别名,许多主机拥有很多不同的主机别名,应用程序可以调用 DNS 来获得主机别名对应的规范主机名以及主机的 IP 地址
2. 邮件服务器别名, 邮件应用程序可以调用 DNS,对提供的主机别名进行解析,已获得该主机的规范主机名及其 IP 地址,事实上,MX 记录允许一个公司的邮件服务器和 Web 服务器使用相同的主机名,即 Web 服务器和邮件服务器可以使用同一个地址
3. 负载分配,DNS 也用于在冗余的服务器(如冗余的 Web 服务器等)之间进行负载分配.


    #### DNS工作机理概括

​ DNS 的一种简单涉及是在因特网上只使用一个 DNS 服务器, 该服务器包含所有的额映射,在这种集中式的设计中,客户直接将所有查询直接发送往单一的 DNS 服务器,同事该 DNS 服务器直接对所有的查询客户做出相应, 因为因特网有着数量巨大(并持续增长)的主机,这种集中式的实际问题包括:

1. 单点故障, 如果该 DNS 服务器崩溃,整个因特网随之瘫痪
2. 通信容量,单个服务器不得处理所有的 DNS 查询
3. 远距离的集中式数据库, 单个服务器不可能"临近"所有查询客户.这可能会导致低速拥塞的链路
4. 维护,单个 DNS 服务器将不各部位所有的英特网主机保留记录,这将会是中央数据库庞大,并且为了解决这个问题而频繁更新

#### 分部署,层次数据库

​ 为了处理扩展性,DNS 使用了大量的 DNS 服务器,使用层次方式组织,并且分布在全世界范围内.将逐渐映射分布在所有的 DNS 服务器上,大致有三种服务器,`根DNS服务器` `顶级域DNS服务器` 和`权威DNS服务器`

1. 根 DNS 服务器,有 400 多个根 DNS 服务器分布在全世界,由 13 个不同的组织管理.
2. 顶级域 DNS 服务器,对于每个顶级域如 com net 和国家级顶级域 cn 都有 TLD 服务器, TLD 服务器提供了权威 DNS 服务器的 IP 地址
3. 权威 DNS 服务器,在因特网上具有公共可访问主机例如 8.8.8.8

​ 还有一种另类的重要 DNS 服务器,称为本地 DNS 服务器, 严格来说并不属于该服务器的层次结构,但是他对 DNS 层次结构是至关重要的

#### DNS 缓存

​ DNS 缓存在英特网上广泛使用,以改善时延性能并减少因特网到处传输的 DNS 报文数量,一般 DNS 服务器在过一段时间后就会清除缓存.

#### DNS 记录和报文

​ 共同实现 DNS 分布式数据库的所有 DNS 服务器储存了`资源记录(Resource Record,RR)`, RR 提供了主机名到 IP 的地址映射,资源记录是包含了如下字段的四个元组:

> (Name, Value, Type, TTL)

​ TTL 是记录生存时间, 他决定而来资源记录应当从缓存中删除的时间,Name 和 Value 的值取决于 Type

- 如果 Type = A, 则 Name 是主机名,Value 是该主机对应的 IP 地址,这就是一条类型 A 记录
- 如果 Type = NS, 则 Name 是个域(如 a.con), 而 Value 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名
- 如果 Type = CNAME, 则 Value 是别名为 Name 的主机对应的规范主机名, 该记录能够查询主机提供一个主机名对应的规范主机名.
- 如果 Type = MX , 则 Value 是一个别名为 Name 的邮件服务器的规范主机名

​

###视频流和内容分发网

#### HTTP 流和 DASH

在 HTTP 流中,视频只是储存在 HTTP 服务器中作为一个普通的文件,每个文件有一个特定的 URL,当用户请求该视频时,客户与服务器创建一个 TCP 连接发送对该 URL 的 HTTP 的 GET 请求,服务器则以底层网络协议和流量条件允许的尽可能快的速率,在一个 HTTP 响应报文中发送视频文件,在客户一侧,字节二笔手机在客户应用缓存中,一旦缓存的字节超过预先设定的门限,客户应用就开始播放

​ 尽管 HTTP 流在实践中得到了广泛部署,但是它具有严重的缺陷,即所有客户收到相同编码的适配,尽管客户可用的宽带大小不同,这导致了一种新型基于 HTTP 的流的研发,在 DASH 中,视频编码为几个不同的版本,其中每个版本都具有不同的 bit 率,对于不同的质量水平,客户动态的请求来自不同版本且长度为几秒的数据块,当可用宽带较高,客户自然选择高速率的版本,反之选择低速率版本

​ DASH 允许客户使用不同的以太网接入速率播放具有不同编码率的视频,当使用 DASH 之后,每个视频版本储存在 HTTP 服务器中,每个版本都有不同的 URL.

#### 内容分发网

​ 为了应对向分布于全世界用户分发巨量视频数据的挑战,几乎所有主要视频公司都会利用`内容分发网`(Content Distribution Network,CDN)

1. CDN 操作,当用户主机中的一个浏览器指令检索一个特定的视频(由 URL 标识),CDN 必须截获该请求以便可以: 确定此时适合该用户的 CND 服务器集群,将客户的请求重定向到该集群的某个服务器,
2. 集群选择策略, 任何 CDN 部署,核心都是集群选择策略,即动态的将客户定向到 CND 中的某个服务器集群或者数据中心机制,一种简单的策略是指派客户到`地理位置最为近邻`的集群.

### 套接字变成: 生成网络应用

​ 网络应用程序有两类,一类由协议标准中定义的操作实现,这种应用程序被称为开放的,另一类网络应用程序是专用的,有客户和服务器程序应用的应用层协议没有公开,有单独的开发者用他的代码实现的功能.

​ [C++ 代码实现 socket 应用](https://github.com/iosh/socket)

​ 与 UDP 不同的是, TCP 是一个面向连接的协议,这意味着在通信发送数据之前,他们需要握手和创建一个 TCP 连接, 当创建该 TCP 连接时, 将其与客户套接字地址和服务器套接字地址关联起来, 使用创建的 TCP 连接, 当一侧向另一侧发送数据, 他只需要经过其套接字将数据丢进 TCP 连接,这与 UDP 不同, UTP 服务器在将分组都进套接字之前还必须为其附上一个目的地址.

​

​ 首先客户端向服务器发起接触任务, 服务器为了能够对客户的初始接触做出反应, 必须已经做好准备,这意味着:第一, 与 UDP 一样, TCP 服务器在客户视图发起接触钱必须作为进程运行起来, 第二, 服务器必须具有一扇特殊的门, 更精确的说是个特殊的套接字, 该问欢迎来自运行在任意主机上的客户进程的某种初始媒介, 使用房子与门来比喻进程与套接字.

​ 随着服务器进程运行,客户端向服务器发送一个 TCP 连接, 由客户程序听过创建一个 TCP 套接字完成的, 当客户生成其 TCP 套接字时, 它制定了服务器中的换乘套接字地址,即服务器主机的 IP 地址及其套接字的端口号,生成其套接字后, 该客户发起了一个三次握手并创建于服务器的一个 TCP 连接, 发生在运输层的三次握手,对客户和服务器程序是完全透明的.

​ 三次握手之间,客户端敲服务器进程的欢迎之门,当该服务器接收到敲门声,它将生成一扇新门(新的套接字),它专用于特定的客户(连接套接字), 之后客户端可以通过这个套接字发送任意字节,并且 TCP 保证服务器进程能够按发送的顺序接收每个字节, TCP 因此在客户和服务器进程之间提供了可靠服务.当然服务器不仅能够从这个套接字中接收字节,也能发送字节.

- [Web 服务器](https://github.com/iosh/socket/tree/master/TCP_Web)

# 运输层

### 概述和运输层服务

​ 运输层协议为运行在不同的应用进程之间提供了`逻辑通信`功能, 通过应用程序的角度看, 通过逻辑通信,运行不同进程的主机好像直接连接在一起.

​ 运输层协议时在端系统而不是在路由器中实现的, 在发送端,运输层从发送应用程序进程接收到的报文转换成运输层分组, 实现方法(可能)是将应用报文划分为较小的块, 并为每块加上一个运输层首部以生成运输报文段,然后在发送端系统规划中,运输层将这些报文段传递给网络层,网络层将其封装成网络层分组并向目的地发送, 网络路由器仅作用于该数据报的网络层字段,不会检查封装在数据报运输层报文段的字段,在接收端,网络层从数据报中提取运输层报文段,并将该报文段向上交给运输层,运输层则处理接收到的报文段,使该报文段中的数据为接收应用程序使用.

### 运输层和网络层的关系

​ 在协议栈中,运输层位于网络层智商,网络层提供了主机之间的逻辑通信,而运输层为运行在不同主机上的进程之间提供了逻辑通信,

​

### 英特网运输概述

​ UDP (用户数据报协议),它为调用它的应用程序提供了一种不可靠,无连接的服务, TCP(传输控制协议),它为调用它的应用程序提供了一种可靠的,面向连接的服务.应用程序开发人员在生成套接字时必须指定选择 UDP 或者 TCP.

​ 因特网网络层协议还有一个名字叫 IP, 即网际协议,IP 为主机之间提供了逻辑通信,IP 的服务模型就是`尽力而为交付服务`,但是也不做任何确保. 即不确保报文交付,不确保报文的按序交付,不确保报文中数据的完整性.也是由于这些原因,IP 被称为`不可靠服务`, 每台主机至少有一个网络层地址,即所谓的 IP 地址.

​ UDP 和 TCP 最基本的责任是,将两个系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务,将主机间交付扩展到进程间交付被称为`运输层的多路复用`与`多路复用`.

​ TCP 微应用程序提供了几种附加服务,首先提供了`可靠数据传输`,通过使用流量控制,序号,确认和定时器,TCP 确保正确的,按序的将数据从发送进程交付给接收进程.TCP 还提供了`拥塞控制`TCP 拥塞控制防止任何一条 TCP 连接用过多地流量来研磨通信主机之间的链路和交换设备,TCP 力求每个通过一条拥塞网络的连接平共享链路宽带,这样可以通过调节 TCP 连接的发送端发送进网络链路的流量速率来做掉,在另一方面 UDP 流量是不可调节的,使用 UDP 传输应用可以根据其需要以其愿意的任何速率发送数据.

### 多路复用与多路分解

> 多路复用与多路分解服务是所有计算机网络都需要的

​ 考虑一台主机如何将接收到的运输层报文定向到适当的套接字, 为此目的,每个运输层报文段中具有几个字段,在接收端,运输层检查这些字段, 标识出接收套接字,从而将报文定向到套接字内,将运输层报文的数据交付到正确的套接字工作成为`多路分解`, 在源主机从不同套接字中接收数据块,并为每个数据块封装封装上首部信息(这将在以后用于分解)从而生成报文段,然后将报文段传递到网络层,这些工作成为多路复用.

​ 运输层多路复用要求:

1. 套接字有唯一标识符
2. 每个报文段有特殊字段来指示该报文段所要交付到的套接字,这些特殊字段是`端口号字段` 和 `目的地端口号字段`(UDP 和 TCP 报文还有一些其他字段),端口号是一个 16bit 的数,其大小在 0 - 65535 之间, 0 - 1023 端口号被称为`周知端口号`,使用时受限制的,他们被指派并保留给诸如 HTTP FTP 之类的协议使用.

​ 在主机上的每个套接字能够分配给一个端口号,当报文段到达主机时,运输层检查报文段中的目的地端口号,并将其定向到相应的套接字,然后报文段中的数据通过套接字进入其所连接的进程.TCP 中的多路复用和多路分解比 UDP 复杂.

​ 当创建一个 UDP 套接字时,运输层自动为该套接字分配一个端口号,特别的是运输层从范围 1024 - 65535 内分配一个端口号, 该端口号是当前一个未被该主机中任何其他 UDP 端口使用的号,另一种是通过创建 UDP 套接字之后可以使用 bind 方法给这个 UDP 套接字关联到一个特定的端口号

​ 一个 UDP 套接字有一个二元组全面标识,该二元组包含一个目的 IP 地址和一个目的地的端口号,因此如果两个 UDP 报文段有不同的源 IP 地址和/或源端口号,但是具有相同目的 IP 地址和目的地的端口号,那么这两个报文将通过项目的目的地套接字被定向到相同的目的地进程.

​ TCP 套接字由一个四元组(源地址 IP,源端口号,目的地 IP,目的地端口号)来标识,因此当一个报文段从网络到达一台主机时,该主机使用全部四个值将报文定向(分解)到响应的套接字,特别的是与 UDP 不同,两个具有不同原地址或者源端口号到达 TCP 报文将被定向到两个不同的套接字,除非 TCP 报文携带了初始创建连接请求.

### 无连接运输: UDP

​ 由[RFC768]定义的 UDP 只是做了运输协议能够做的最少工作,除了复用/分解功能以及少量的差错检验之外,他几乎没有对 IP 增加别的东西,如果是用 UDP 那么应用程序基本上就是直接与 IP 打交道,UDP 从应用进程得到数据,附加上英语多路复用/分解服务的源和目的地端口号字段,以及其他的两个小字段,然后形成报文段交给网络层,网络层将该运输协议封装到一个 IP 数据报中,然后尽力而为尝试将次报文段交付给接收主机,使用 UDP 时发送方和接收方的运输实体层没有握手,所以 UDP 被称为是无连接的.

​ TCP 和 UDP 差异以及不同情况下的优劣

1. TCP 在关于发送什么数据以及何时发送多的应用层控制更为精细

   采用 UDP 时,只要将应用进程数据传递给 UDP,UDP 就会将次数据打包进 UDP 报文,,并立即传递给网络层,而 TCP 用用拥塞控制机制,一遍当源和目的主机间的一条或者多条链路拥塞时来遏制运输层 TCP 发送方.TCP 会将接收方未收到的数据报文重新发送,直到目的主机收到此报文并加以确认,而不管可交付需要多长时间,对应的如果允许少量丢失,以及对速度要求都可以使用 UDP.

2. UDP 无需建立连接

   TCP 在开始数据传输之前要进行三次握手,UDP 缺不需要任何准备即可进行数据传输, 因此 UDP 不会有建立连接时的延迟

3. UDP 无连接状态

   TCP 需要在端系统中维护连接状态,此链接状态包括接收和发送缓存,拥塞参数控制以及序号与确认序号的参数,要实现 TCP 的可靠数据传输服务并且提供拥塞控制,这些信息是必要的.而 UDP 不维护连接状态,也不跟踪这些参数,因此某些程序运行在 UDP 之上能比 TCP 支持更多活跃用户.

4. 分组开销小

   TCP 报文端都有 20 字节的首部开销,而 UDP 仅有 8 字节的开销

### UDP 检验和

​ `UDP检验和`提供了差错检验功能,用于确定当 UDP 报文段从源到达目的地移动时,其中 bit 是否发生了改变,方方的 UDP 对报文段中多有 16bit 紫的和进行反码运算,求和时遇到的任何一处都被回卷,得到的结果被放在 UDP 报文段中的检验和字段中.

### 可靠数据传输原理

​ 可靠数据传输的实现问题不仅在运输层出现,也会在链路层以及应用层出现.一般来说性能问题对网络来说更为重要,而在其他重要问题中可靠数据传输则是有力竞争选手.

​

### 构造可靠数据传输协议

​ 通过一步一步研究协议,实现一个完美可靠的传输协议

1. 最简单的情况是,底层信道是完全可靠的,即发送出去的信息一定会被送到.不会出任何差错而且假定发送方速率和接收方速率相等. --底层信道可靠,不会传输出错,速率相等 协议 0.1

2. 底层信道更为实际的模型是分组中的比特可能受损,在分组传播或缓存过程中,bit 差错可能会出现网络的部件中,因此要实现可靠的数据传输协议,必须解决这个问题,在计算机网络中基于一种被称为自动重传请求的协议来实现可靠数据传输,自动重传请求协议还需要其他另外三种协议工来来处理比特差错情况

   1. 差错检测, 需要一种机制以使接收方检测到何时出现了比特差错.类似于 UDP 的差错和.
   2. 接收方反馈, 因为接收方和发送方通常在不同端系统上执行,发送方需要了解接收方情况的唯一途径就是让接收方提供明确反馈信息给发送方.
   3. 重传, 接收方收到由差错的分组时,发送方将重传该分组

   此时便得到了拥有:检查错误,接受反馈和重传机制的 协议 0.2

3. 现在除了假定比特受损外,还要考虑到底层信道还会丢包, 通常会设定一个时间阈值,超过这个值之后就会被认定为丢包, 所以使用倒计数定时器基于重传来实现这个功能,在一个给定时间量过期后,终端发送方,因此发送方徐亚能做到:

   1. 每次发送一个分组(包括第一次分组和重传分组)时,便启动一个定时器
   2. 响应定时器中断(采取合适的操作)
   3. 终止定时器

   便得到了超时重传的 0.3 协议

​ 总结数传可靠传输要点: 在检验和, 序号, 定时器, 肯定以及否定确认分组这些技术中,每种机制在协议运行中起到了必不可少的作用,至此得到了一个可靠的数据传输协议.

### 流水线可靠数据传输

​ 上面的 0.3 协议已经是一个功能正确的协议,但是他的性能不是太令人满意特别是在今天的高速网络中

​ 解决这个特殊的性能问题的方法是: 不以停等方式运行,允许发送方发送多个分组而无需等待确认,以解决以前必须等到回复才会发送下一个分组所产生的额性能问题.

​ 如果可以在回复之前发送三个分组,那么相比较以前利用率提升了三倍,因为许多从发送方向接收方输送的分组可以看成是填充到一条流水线中,故这种技术被称为流水线(pipelining).流水线技术对可靠数据传输协议可带来如下影响:

1. 必选增加序号范围,因为每个传输中的分组必须有一个唯一的序号,而且也许有多个在传输中的未确认报文
2. 协议的双方也不得不缓存多个分组,发送方最低限度能缓存哪些已经发送但没有确认的分组,如下面讨论那样,接收方获取需要缓存哪些已经正确接收的分组
3. 所需需要范围和对缓冲要求取决于数据传输协议如何处理丢失,损坏及延时过大的分组,解决流水线的和差错回复有两种基本方法:`回退N步` 和 `选择重传`

#### 回退 N 步

​ 在回退 N 步协议中,允许发送方发送多个分组(当多个分组可用时),而不需要等待确认,但它也受限于在刘淑贤中未确认的分组数不能超过某个最大数 N. 那些已被发送但还未确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口,随着协议的运行,该窗口可在序号空间向前滑动,因此,N 常被称为`窗口长度`, GBN 协议也被常称为`滑动窗口协议`.

​ GBN 发送方必须响应三种类型事件:

1. 上层的调用.发送方首先检查发送窗口是否已满,即是否有 N 个已经发送但未被确认的分组,如果窗口未满,则产生一个分组将其发送,并响应更新变量.如果窗口已满,发送方只需将数据返回给上层,隐式地指示上层该窗口已满,然后上层可能过一会再试,在现实中发送方更可能缓存这些数据等待发送.
2. 收到一个 ACK.在 GBN 协议中,对序号为 n 的分组采取`累积确认`的方式,表明接收方已经正确接收到序号为 n 的以前包括 n 在内的所有分组
3. 超时事件,协议的名字`回退N步`来源于出现丢失和时延过长分组时发送方的行为,就像在等停协议中那样,定时器将再次用于恢复数据或确认分组的丢失,如果出现超时,发送方重传所有已发送但是还未被确认过的分组,如果收到一个 ACK,但仍有已发送未被确认的分组,则定时器被重新启动,如果没有已发送但未被确认的分组,停止该定时器

#### 选择重传

​ GBN 协议潜在的允许发送用多个分组`填充流水线`因此避免了协议中提到的信道利用率的问题,然而 GBN 本人也存在性能问题,尤其是当前窗口长度和宽带延迟都很大的时候,在流水线中会有很多分组更是如此,单个分组的差错就能引起 GBN 重传大量分组,然而很多分组没必要重传,随着差错率的增加,流水线可能会被这些不必要的重传分组所充斥,

​ 而选择重传协议通过让发送发进重传哪些它换衣在接收方出错的的分组而避免了不必要的重传,这种个别,按需的重传要求接收方逐个的确认正确接收的分组,再次用窗口长度 N 来限制流水线中未完成未确认的分组数,然而与 GBN 不同的是,发送方已经手打了对窗口中某些分组的 ACK.

### 面向连接的运输: TCP

​ 学习了可靠运输的基本原理,而 TCP 是因特网运输层的面向连接的可靠的运输协议

#### TCP 连接

​ TCP 被称为是`面向连接的`这是因为在一个应用进程可以开始向另一个应用进程发送数据之前,两个进程必须先相互握手,即他们必须相互发送某些预备报文段,以建立确保数据传输的参数,作为 TCP 连接建立的一部分,连接的双方豆浆初始化 TCP 连接相关的许多 TCP 状态变量.

​ 连接时一条逻辑连接,其共同状态仅保留在两个同心端系统的 TCP 程序中,由于 TCP 协议只在端系统中运行,而不在中间的网络元素(链路和交换机)中运行,所以中间元素不会维持 TCP 连接状态,事实上中间路由器对 TCP 连接完全视而不见,他们看到的是数据,而不是连接.

​ TCP 连接时`全双工服务`:如果一台主机上的进程 A 与另一个主机上的进程 B 存在一条 TCP 连接,那么应用层数据就可以从进程 B 流向进程 A 的同事,也从进程 A 流向进程 B,TCP 连接也总是`点对点`的,即在单个发送方与单个接收方之间的连接,所谓`多播`,即在一次发送操作中,从一个发送方将数据传送给多个接收方,这种情况对 TCP 来说是不可能的,对于 TCP 而言是一对一的.

​ TCP 是通过如下方式来建立连接的:

1. 客户首先发送一个特殊的 TCP 报文段,服务器用另一个特殊的 TCP 报文段来响应,最后客户在用第三个特殊报文段作为相应,前两宝报文段不承载`有效荷载`不包含应用层数据,而第三个报文段可以承载有效荷载,由于两个主机之间发送了三个报文段,所以这种连接过程被称为`三次握手`.
2. 通过`三次握手`建立了连接,客户通过套接字传递数据,数据一旦通过该门,它就由客户中运行的 TCP 控制了,TCP 将这些数据引导到该连接的`发送缓存`里,发送缓存是发起三次握手期间设置的缓存之一,再接下来 TCP 会不时的从发送缓存中取出一块数据,并将数据传递到网络层.
3. TCP 为每块客户数据配上一个 TCP 首部,从而形成多个`TCP报文段`这些报文段被下传给网络层,网络层将其分别封装在网络层 IP 数据报中,然后这些 IP 数据报被发送到网络中,当 TCP 在另一端接收到一个报文段后,该报文段的数据就被放入该 TCP 连接的接收缓存中,之后应用程序从此缓存中读取数据流.该连接的每一段都有各自的发送缓存和接收缓存

​ 所以综上所述,TCP 的连接组成包括:一台主机上的缓存,变量和御锦城连接的套接字,以及另一台主机上的另一组缓存,便令与进程连接的套接字

#### TCP 报文段结构

​ TCP 报文段由首部字段和一个数据字段组成,数据字段包含一块应用数据.

​ 与 UDP 一样,首部包含了源端口号和目的地端口号,他被用于多路复用/分解来自或送到应用层的数据,另外还包含`检验和字段`,TCP 报文首部还包含下列字段:

1. 32 比特的`序号字段`和 32 比特的`确认号字段`这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务
2. 16 比特的`接收窗口字段`该字段用于流量控制,该字段用于指示接收方愿意接收的字节数量
3. 4 比特的`首部长度字段`该字段知识了以 32 比特的字为单位的 TCP 首部长度,由于 TCP 选项字段的原因,TCP 首部的长度是可以变的.
4. 可选与变长的`选项字段`,该字段用于发送方和接收方协商最大报文长度时,或在高速网络环境下用作窗口调节因子时使用个,首部字段中还顶一个了一个时间戳
5. 6 比特的`标志字段`ACK 比特用于指示去人字段中的的值是有效的,即改吧文已经被承购接受报文段的去人,RST,SYN 和 FIN 比特用建立连接和拆除.在明确拥塞通告中使用了 CWR 和 ECE 比特,最后使用 URG 比特用来是指报文段里存在着被发送端的长层实体置为紧急的数据,金及数据的最后一个字节由 16 比特的金及数据指针字段指出,当金及数据存在并给出指向紧急数据指针的时候,TCP 必须通知和接收端的上层实体.

​ 序号和确认号,这两个字段是 TCP 报文首部最重要的字段,这两个字段是可靠传输服务的关键部分

​ TCP 吧数据看成一个无结构的,有序的字节流,一个报文段的序号是该报文段首字节的字节流编号,举例来说假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流,主机 A 中的 TCP 将隐式地对数据流中的每一个字节编号.

​ 确认号比序号难处理一些,TCP 是全双工的,因此主机 A 在向主机 B 发送数据的同时,也许叶鏊收到来自主机 B 的数据(都是同一条 TCP 连接的一部分),从主机 B 到达的每个报文段中都有一个序号用于从 B 流向 A 的数据,主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号.

#### TCP 连接管理

​ 客户中的 TCP 会用以下方式与服务器中的 TCP 建立一条 TCP 连接:

1. 第一步 客户端的 TCP 首先向服务器端的 TCP 发送一个特殊的 TCP 报文,该报文中不包含应用层数据,但是在报文段的首部中的一个标志位(即 SYN 比特)被置为 1,因此,这个特殊报文段被称为 SYN 报文段,另外客户会随机的选择一个初始序号,并将此编号放置于该起始的 TCP SYN 报文段的序号字段中,该报文段会被封装在一个 IP 数据报中,并发给服务器,为了避免某些安全性攻击,在适当的随机化选择 client isn 方面有着不少又去的研究
2. 第二步 一旦包含 TCP SYN 报文段的 IP 数据报达到服务器,服务器会从该数据报中提出 TCP SYN 报文段,为该 TCP 连接分配 TCP 缓存和变量,并向该客户 TCP 发送允许连接的报文段,这个允许连接的报文段也不包含应用层数据,但是在报文段的首部却包含三个重要的信息,首先 SYN 比特被置为 1,其次,该 TCP 报文段首部的确认号字段被置为 client isn + 1,最后,服务器选择自己的初始化序号,并将其放到 TCP 报文段首部的序号字段中,该允许连接的报文段被称为 SYNACK 报文段
3. 第三步 在收到 SYNACK 报文段后,客户也要给该连接分配缓存和变量,客户主机则向服务器发送另外一个报文段,最后一个报文段对服务器的允许连接的报文段进行了去人,因为连接已经建立了,所以该 SYN 比特被置为 0,该三次握手的点个步骤可以在报文段负债中携带客户到服务器的数据

### 拥塞控制原理

​ 一般而言丢包是当网络变得拥塞时由于路由器缓存溢出引起的，分组重传音符作为网络拥塞的征兆来对待，但是却无法处理导致网络拥塞的原因，因为有太多的源想以过高的速率发送数据，所以需要一些机制在面临网络拥塞的时候抑制发送方.

#### 拥塞的原因和代价

​ 随着主机增加其发送率并使网络变得拥塞时会发生以下几种情况

1. 情况一:两个发送方和一台具有无穷大缓存的路由器

   假设有两台主机都有一条了解,且这链条链接共享源于目的地之间的单跳路由,.......在这种极端理想化的情况下,拥塞网络的代价是,即当分组到达速录接近链路容量事,分组讲经历巨大的排队时延.

2. 情况二: 两个发送方和一台具有有限缓存的路由

   假定路由的容量是有限的,当分组到达一个已满的缓存时就会被丢弃,其次假定链接是可靠的,如果分组被丢弃那么他讲被发送方重传,在情况 2 下实现的性能强烈地依赖于重传的方式,首先假设能以某种方式确认路由器是否还有缓存,并且仅当有缓存的时候才发送分组,那么将不会产生丢包,在这种情况下,从吞吐量角度看,性能是理想的,即发送的每个分组都被接收到.

   假定一种更为真实的情况,发送方仅当在确定了一个分组已经丢失时才重传,.....另一种拥塞的代价就是,即发送方必须执行重传以补偿因为缓存溢出儿丢失/丢弃的分组

3. 情况三: 四个发送方和具有优先缓存的多台路由器及多跳路径

   在最后一种拥塞情况中,有四台主机发送分组,每台都通过交叠的两跳路径传输,再假定每台主机都采用超时重传机制来实现可靠数据服务......在此情况下拥塞的代价是,当因为拥塞而丢弃某个分组的时候即当前一个分组沿一条路径呗丢弃时,每个上路由器由于穿法改分组到丢弃该分组而使用的传输容量最终被浪费掉了.

#### 拥塞控制方法

​ 下面将两种在实践中采用的拥塞控制方法,在最宽泛的级别上,可以根据网络成是否为运输层拥塞控制提供了显式帮助来区分拥塞控制方法:

1. 端到端拥塞控制

   网络层没有为运输层拥塞控制提供显式支持,即使网络中存在拥塞,端系统也必须通过对网络行为的观察来推断,TCP 采用端到端的方法解决拥塞控制,因为 IP 层不会像端系统提供有关网络拥塞的反馈信息.TCP 报文段的丢失(例如丢失或超时三次冗余未确认)被认为是网络拥塞的一个迹象,TCP 会相应减少其窗口长度。关于对 TCP 拥塞控制的一些新建议，即使用增加往返时延值作为网络拥塞程度增加的指示

2. 网络辅助的拥塞控制

   在网络辅助的拥塞控制中,路由器像发送方提供关于网络中拥塞状态的显式反馈信息,这种反馈可以简单地用一个比特来指示链路中的拥塞情况.来实现网络拥塞控制,因特网默认版本的 IP 和 TCP 采用端到端拥塞控制方法,最近 IP 和 TCP 也能够选择性的实现网络服辅助拥塞控制

#### TCP 拥塞控制

​ TCP 为运行在不同主机上的连个进程之间提供了可靠传输服务,TCP 的另一个关键部分就是其拥塞控制机制,因为 IP 层没有网络拥塞反馈,所以 TCP 必须使用端到端拥塞控制而不是网络服务助的拥塞控制.

​ 这种拥塞控制方法提出了按个问题:

1. 一个 TCP 发送方如何限制它想其连接发送流量速率

2. 一个 TCP 发送方如何感知从它到目的地之间路径上存在拥塞

3. 当发送方感知到端到端拥塞时，采用何种方法来改变其发送速率

   运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥`拥塞窗口`,拥塞窗口表示为 cwnd,他对一个 TCP 发送方能向网络中发送流量的速率进行了控制,特别的是发送方中未被确认的数量不会超过 cwnd 于 rwnd 中的最小值

   > LastByteSent - LastByteAcked <= min {cwnd,rwnd}

​ TCP 使用下列指指导性解决一些问题：

1. 一个丢失的报文段意味着拥塞
2. 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认送达时，能够增加发送方的速率
3. 宽带探测，给定 ACK 指示源到目的地路径无拥塞，而丢包事件指示路径拥塞，TCP 调节其传输速率的策略是增加其速率以响应到达 ACK，除非出现丢包事件，此时才减小传输速率。

​ `TCP拥塞控制算法`中描述并且标准化,改算法主要包括三个主要部分:

1. 慢启动

2. 拥塞避免

3. 快速恢复

   慢启动和拥塞避免是 TCP 的墙纸部分,两者的差异在于对收到的 ACK 做出反应时增加 cwnd 长度的方式

1) 慢启动

   当一条 TCP 链接开始时,cwnd 的值通常初始设置为 MSS 的较小值,这样就使得初始速率大约为 MSS/RTT.对于 TCP 发送方而言,可用宽带可能比 MSS/RTT 大得多,TCP 发送方希望迅速找到可用的宽带数量,因此,在`慢启动`状态,cwnd 的值以 1 个 MSS 并且每当传输的报文段首次被确认就增加一个 MSS,TCP 发送速率起始慢,但在慢启动阶段以指数增长.当出现一个由超时指示的丢包事件,TCP 发送方讲 cwnd 设置为 1 并重新喀什慢启动过程,他还将第二个状态的变量值 ssthresh 设置为 cwnd/2,即当检测到拥塞时讲 ssthresh 置为拥塞窗口值得一半.慢启动结束的第二种方式是直接与 ssthresh 的值相关联,因为当检测到拥塞时 ssthresh 设置为 cwnd 的值一半,当到达或超过 ssthresh 的值时,继续使 cwnd 翻番可能有些鲁莽,因此当 cwnd 的值等于 ssthresh 时,结束慢启动并且 TCP 转移到拥塞避免模式

2) 拥塞避免

   进入拥塞避免模式,cwnd 的值大约是上次遇到拥塞时的一半,对于 TCP 发送方无论何时到达一个新的确认,就将 cwnd 增加一个 MSS 字节.

3) 快速恢复

   在快速恢复中,对引起 TCP 进入快速恢复状态的确实报文段,对收到的每个冗余的 ACK,cwnd 的值增加一个 MSS,最终,当对丢失报文段的一个 ACK 到达时,TCP 在降低 cwnd 后进入拥塞避免状态,如果出现超时时间,快速恢复在执行如同在慢启动和用丝避免重想通过的动作后,迁移到快慢启动状态,当丢包时间出现时 cwnd 的值被设置为 1MSS,并且 ssthresh 的值这职位 cwnd 的值的一半.

# 网络层:数据平面

## 网络层概述

​ 一个简单网络中,有 a.b 两台主机,他们之间有几台路由器,啊,相比发送信息,a 中的网络层取得来自 a 运输层的报文段,将每个保额文段封装成一个数据报,然后向相邻路由器发送该数据报,在接收方主机 b,网络层接收来自相邻路由器的数据报,提出运输层数据报文段,向上交给 b 的运输层,每台路由器的数据平面的主要作用是从输入链路向输出链路转发数据报,控制平面的主要作用是鞋套这些本地的路由器转发动作,是的数据报沿着源和目的地主机之间的路怄气路径最近进行端到端的传输.

### 转发和路由选择:数据平面和控制平面

​ 网络层的作用从表面上看起来极为简单,即将分组从一台方发送主机移动到一台棘手主机,为此,需要使用两种重要的网络层功能.

- 转发

  当分组到达某个路由器的一条输入链路时,该路由器必须将该分组移动到适当的输出链路,

- 路由选择

  当 m 分组从发送方流向接收方时,网络层必须决定这些分组所采用的路由或路径,计算这些路径的算法被称为`路由选择算法`

​ 每台网络路由中有一个关键元素是他的`转发表`,路有检查到达分组首部的一个或者多个字段,进而使这些首部值在转发表中索引,通过这种方法来转发分组,这些值对应储存在转发表中的值,指出了该分组将被转发的路由器的纯输出链路接口.

​

### 网络服务模型

​ 网络服务模型定义了分组在发送与接收端系统之间的端到端运输特性

​ 网络层可能提供以下服务:

- 确保交付 该服务确保分组将最终到达目的地
- 具有时延上街的确保交付 该服务不仅确保分组的交付,而且在特定主机到特定主机时延上届(例如 100ms)交付
- 确保最小宽带 这种网络服务模仿在发送和接收方主机之间一条特定比特率(例如 10Mbps)的传输链路的行为,只要发送主机以低于特定比特率的速率传输比特则左右分组最终会交付目的地主机
- 安全性 网络层能够在源加密所有数据报并在目的地解密这些分组,从而对所有运输层报文段提供机密性

​ 以上只是网络层能够提供的服务的部分列表,有无数种可能的服务变种

​ 英特网的网络层提供了单一的服务,称为`尽力而为服务`,使用尽力而为服务,传送的分组既不能保证他们发送的顺序被接收,也不能保证他们最终交付,既不能保证端到端时延,也不能保证 有最小宽带,服务看起来不怎么美好,但是有其他的服务可供选择,而且因特网的尽力而为服务在与适当的宽带结合已经被证实为`足够好`,能够用于大量的应用.

### 路由器工作原理

​ 一般而言路由器有四个组件

- 输入端口 输入端口执行几项重要功能,他在路由器中执行终结入物理链路的物理层功能,在输入端口还要执行查找功能,通过查询转发表决定路由器的输出端口,到达的分组通过路由器的交换结构转发到输出端口.
- 交换结构 交换结构将路由器输入端口连接到它的输出端口,这种交换结构完全包含在路由器之中,即他是一个网络路由器中的网络.
- 输出端口 输出端口储存从交换接口接收的分组,并通过执行必要的链路层和物理层功能在输出链路上传输这些分组,当一条链路时双向的时,输出和输入通过出现在同一线路卡上
- 路由选择处理器 路有选择处理器执行平面控制功能,在传统的路由器中,它执行路由选择协议,维护路有选择表与关联链路状态信息,并为该路由器计算转发表,在 SDN 路由器在中路有选择处理器负责与远程控制器通信,目的是接收远程控制器的转发选项,并在该路由器的输入段开口安装这些表项,路由选择处理器还执行网络管理功能.

### 输入端口处理和基于目的地转发

​ 比较简单的转发表是路由器用分组目的地址的前缀与该表的表项进行匹配,如果存在一个匹配项,则路由器向该匹配项相关联的链路转发分组.可能会匹配多个,当有多个匹配时,该路由器使用`最长前缀匹配规则`即在该表中寻找最长的匹配项,并向与做场匹配相关的链路接口转发分组.

### 交换

​ 交换结构位于路由器的核心部位,通过交换结构,分组才能实际的从输入端口交换到输出端口中,交换可以通过多种方式

- 经内存交换 最简单,最早的路由器时传统计算机,在输入端口和输出端口之间的交换是在 CPU 的直接控制下完成的.现代许多路由器通过内存交换,与早期路由器主要差别是,目的查找和将分组储存/交换仅适当的内存存储位置是由输入线路卡类处理的.
- 经总线交换 在这种方法中 输入端口经一根共享总线将分组直接传送到输出端口,不需要路由选择处理器的干预,通常按以下方式完成该任务:让输入端口为分组预先计划一个交换机内部标签,直视本都输出端口,使分组在总线上传输和传送到输出端口,该分组能由所有输出端口接收到,但是只有与该标签匹配的端口才能保存该分组,然后标签在输出端口被去除,因为其仅用于交换机内部来跨越总线.一次只能有一个分组跨越总线,所以路由器收到总线速率限制.
- 经互联网贾环 客户单一 贡献是总线带宽限制的一种方法是,使用更复杂的互联网络,与前两种交换方式不同,纵横式网络能够并行转发多个分组,纵横式交换机是`非阻塞`的即只要没有其他分组当前被转发到该输出端口,转发到输出端口的分组将被到达输出端口的分组阻塞,然后如果来自两个不同输入端口的两个分组其目的地为相同的输出端口,另一个分组必须在输入端等待

### 输出端口处理

​ 输出端口处理取出已经存放在输出端口内存中的分组并肩齐发送到输出链路上,这包括选择和取出排队的分组进行传输,执行所需的链路层和物理传输功能

### 何时出现排队

​ 在输出和输入端口都可以想形成分组队列,排队的位置和程度将取决于流量负载,交换结构的相对速率和线路速率,随着这些队列的增长,路由器的缓存空间最终将会耗尽,并且当无内存可用于储存到达的分组时将会出现丢包

1. 输入排队

   如果交换结构不能是所有到达分组无延时通过他传输,在输入端口将出现分组排队,这种现象叫做输出入配对交换机中的`线路前部阻塞`即在一个输入队列中排队的分组必须等待通过交换结构发送,因为他被位于线路前部的一个分组所阻塞.

2. 输出排队

   因为输出端口在一个单位时间(该分组的传输时间)内只能传输一个分组,这 N 个到达分组必须排队等待经输出链路传输,当没有足够内存来缓存一个入分组时,就必须做出决定,要么丢弃到达的分组采用弃尾策略,要么删除一个或者多个已经在队列里面的分组,在某些情况下,在缓存填满之前便丢弃一个分组的做法是有力的,这可以给发送方发送一个拥塞信号,随机早期检测算法是德达最广泛研究和实现的 AQM 算法之一.

### 分组调度

​ 路由器有很多排队规则,一种是先进先出,一种是基于优先级,还有加群循环以此提供服务

1. 先进先出 调度规则按照分组到达输出链路队列的相同粗徐来选择分组在链路上传输
2. 优先权队列 在`非抢占式优先权排队`规则下,一旦分组考试传输就不能被断,之后优先传输有优先权的分组
3. 循环加权公平排队 像使用有限排队那样被分类,然后在类之间不存在严格的服务优先权,循环调度器在浙西二类之间轮流提供服务,例如先传输一个高权限的分组之后传输一个低权限的分组,

### 网际协议:IPv4 寻址 IPv6 及其他

​ 目前有两个版本的 IP 正在使用,首先是广泛部署的 IP 版本 4,和未来新星 IP 版本 6,还有学习英特网编址,掌握 IP 地址就是已掌握英特网的网络层.

#### IPv4 数据报格式

​ 网络层分组被称为`数据报`数据报,在因特网中起至关重要的作用.

​ IPv4 数据报中的关键字段如下:

1. 版本号 使用四个比特储存了数据报的 IP 协议版本,通过查看版本号,路由器能够确定如何解释 IP 数据报的剩余部分.不同版本的 IP 使用不同的数据格式.
2. 首部长度 IPv4 数据报可以包含一些可变两的选项,用四个比特来确定 IP 数据报中符合实际开始的地方.大多数 IP 数据报不包含选项,所以一般的 IP 数据报具有 20 字节的首部
3. 服务类型 服务类型以便使不同类型的 IP 数据报能够相互泣别开来.
4. 数据报长度 是 IP 数据报的总长度,以字节计,该字段长度为 16 比特,所以数据报的理论最大长度为 65535 字节.然而数据报很少有超过 1500 字节,该长度使得 IP 数据报能够容纳最大长度以太网帧的载荷字段
5. 标识 标志 片偏移 这三个字段与所谓的 IP 分片有关, 新版 IPv6 不允许在路由器上对分组分片
6. 寿命 字段用来确保数据报不会永远在网络中循环,每当一台路由器处理数据报时,该字段的值减一,若 TTL 字段为 0,则丢弃该数据报
7. 协议 该字段通常仅当一个 IP 数据报到达其目的地的时候才会用,该字段值指示了 IP 数据报的数据部分应该交给那个特定的运输层协议.例如值为 6 则交给 TCP 值为 7 则交给 UDP
8. 首部校验和 首部校验和用于帮助路由器检测收到的 IP 数据报中的比特错误,首部校验和是这样计算的:将首部中的没两个字节当做一个书,用反码技术对这些数求和.
9. 源和目的地 IP 地址 当某个源生成一个数据报时,他在源 IP 字段中插入他的 IP 地址,在目的 IP 地址字段中插入其最终的目的地的地址,通过源主机通过 DNS 查找来决定目的地地址.
10. 选项 字段允许 IP 首部被扩展,首部选项意味着很少使用,因此决定对每个数据报收不包括选项字段中的信息,在 IPv6 中已经去掉了这一项.
11. 数据 有效载荷 IP 数据报中的数据字段包含要交付给目的地的运输报文段(TCP 或 UDP)然而,该数据字段也可以承载其他类型的数据,如 ICMP 报文

#### IPv4

​ 一个链路层帧能承载的最大数据量叫做`最大传送单元`,因为每个 IP 数据报封装在链路层帧中从一套路由器传输到下一台路由器,故链路层协议的 MTU 严格的限制着 IP 数据报的长度,对 IP 数据报长度具有严格限制不是问题,问题在与发送方与目的地路径上的每段链路可能使用不同的的链路协议,且每种协议可能具有不同的 MTU.

#### IPv4 编址

​ 每个 IP 地址长度为 32 比特,因此总共有 2^32 个(大约 40 亿个)可能的 IP 地址,这些地址通常按照`点分十进制记法`书写,即地址中每个字节用他的十进制形式书写,各字节间以句点隔开

#### IPv6

​ 为了应对 IPv4 地址耗尽,因特网工程组就开始致力于开发一种代替 IPv4 的协议,即 IPv6.

​ IPv6 中引入的最重要的变化显示在其数据报格式中:

1. 扩大的地址容量 IPv6 将 IP 地址长度从 32 位比特扩展到 128 位比特,这样就确保了地球上每一粒沙子都可以使用 IP 寻址了, IPv6 还引入了一种称为`传播地址`的新型地址,这种地址可以使数据报交付给医嘱主机中任意一个
2. 简化高效的 40 字节首部 在 IPv4 中很多首部字段在 IPv6 中都设去掉了,因而形成的 40 字节定长首部允许路由器更快的处理 IP 数据报,一种新的选项编码允许进行更灵活的选项处理
3. 流标签 IPv6 有一个难以捉摸的流字段,该字段可以用于给`数据域特殊流的分组加上标签,这些特殊流是发送方要求进行特殊处理的流,如果一种非默认服务质量或者需要试试服务的流`如音频和视频就可以被当做一个流,另一方面传统的文件传输和电子邮件就不可能被当做流,由高优先权用户承载的流量也有可能被当做一个流.
4. 版本 该 4 比特字段用于表示 IP 版本号
5. 流量类型 该 8 比特字段与 IPv4 中的 TOS 字段含义相似
6. 有效载荷长度 该 16 比特值作为一个无符号整数,给出了 IPv6 数据报中跟定长的 40 阶数据报首部后面的字节数量
7. 下一个首部 该字段表示数据报中的内容需要交付给那个协议
8. 跳限制 转发数据报的每台路由器将对该字段内容减一,如果值到 0 则丢弃
9. 源地址和目的地址
10. 数量 IPv6 数据报的有效载荷部分,当数据报到达目的地是,该有效载荷就从 IP 数据报中移出,并交给在下一个首部字段中指定的协议处理
11. 分片/重新组装 IPv6 不允许在中间路由器上进行分片与重新组装,这种操作只能在源与目的地执行,如果路由器收到的 IPv6 数据报因为太阿而不能转发到出链路上,则路由只需要丢弃该数据报,并向发送方发回一个`分组太大`的 ICMP 差错报文即可.发送方在重新发送一个较小的 IP 数据报.
12. 首部检验和

.
