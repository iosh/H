<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"github.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="React in patterns 观看笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="React详细介绍">
<meta property="og:url" content="https://github.com/iosh/H.git/2018/04/22/React%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="胡先生">
<meta property="og:description" content="React in patterns 观看笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-04-22T16:13:06.000Z">
<meta property="article:modified_time" content="2024-07-06T12:26:18.045Z">
<meta property="article:author" content="H">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://github.com/iosh/H.git/2018/04/22/React%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://github.com/iosh/H.git/2018/04/22/React%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","path":"2018/04/22/React详细介绍/","title":"React详细介绍"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>React详细介绍 | 胡先生</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">胡先生</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5"><span class="nav-number">1.1.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.</span> <span class="nav-text">输出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-React-%E7%9A%84-children-API"><span class="nav-number">3.1.</span> <span class="nav-text">使用 React 的 children API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BD%9C%E4%B8%BA-Porps"><span class="nav-number">3.2.</span> <span class="nav-text">传递一个子组件作为 Porps</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">高阶组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#render-props"><span class="nav-number">4.1.</span> <span class="nav-text">render props</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">受控组件和非受控组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">展示组件和容器组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">6.1.1.</span> <span class="nav-text">提取容器组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6"><span class="nav-number">6.1.2.</span> <span class="nav-text">展示组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E6%A0%B7%E5%81%9A%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">6.1.3.</span> <span class="nav-text">这样做的好处</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">Flux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatcher"><span class="nav-number">8.1.</span> <span class="nav-text">dispatcher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0-View-%E5%92%8C-Store"><span class="nav-number">8.2.</span> <span class="nav-text">更新 View 和 Store</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Flux-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.1.</span> <span class="nav-text">使用 Flux 辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-context"><span class="nav-number">8.2.2.</span> <span class="nav-text">使用 context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E6%A6%82%E5%BF%B5"><span class="nav-number">8.2.3.</span> <span class="nav-text">高阶组件概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E8%80%85%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">8.2.4.</span> <span class="nav-text">作者的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#action"><span class="nav-number">8.2.5.</span> <span class="nav-text">action</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">9.</span> <span class="nav-text">Redux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Actions"><span class="nav-number">9.1.</span> <span class="nav-text">Actions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Store"><span class="nav-number">9.2.</span> <span class="nav-text">Store</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reducer"><span class="nav-number">9.3.</span> <span class="nav-text">Reducer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0-React-%E7%BB%84%E4%BB%B6"><span class="nav-number">9.4.</span> <span class="nav-text">连接到 React 组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">9.5.</span> <span class="nav-text">一个简单的计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-action"><span class="nav-number">9.5.1.</span> <span class="nav-text">创建 action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Store-%E5%92%8C-reducer"><span class="nav-number">9.5.2.</span> <span class="nav-text">Store 和 reducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E7%BB%84%E4%BB%B6"><span class="nav-number">9.5.3.</span> <span class="nav-text">React 组件</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">H</p>
  <div class="site-description" itemprop="description">个人学习笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/iosh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iosh" rel="noopener me"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/iosh/H.git/2018/04/22/React%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="H">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡先生">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="React详细介绍 | 胡先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React详细介绍
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-22 16:13:06" itemprop="dateCreated datePublished" datetime="2018-04-22T16:13:06+00:00">2018-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-06 12:26:18" itemprop="dateModified" datetime="2024-07-06T12:26:18+00:00">2024-07-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="https://krasimir.gitbooks.io/react-in-patterns/content/">React in patterns</a> 观看笔记</p>
<span id="more"></span>
<h1>通讯</h1>
<p>每个 React 组件就像一个独立运行的小系统，他有自己的输入和输出，分别讲一下</p>
<h2 id="输入">输入</h2>
<p>在 React 中是通过 props 进行输入的，就像下面这样的</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Title</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这段是定义 props 类型</span></span><br><span class="line"><span class="title class_">Title</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这段定了 props 的默认值</span></span><br><span class="line"><span class="title class_">Title</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果这里传了 text 属性，那么就会覆盖上面定义的 text: &#x27;Hello world&#x27;，如果没定义 就会text属性就会默认被定义为 text: &#x27;Hello world&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Title</span> <span class="attr">text</span>=<span class="string">&quot;Hello React&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>Title</code>组件只有一个 props 属性<code>text</code> ，父组件 <code>App</code> 在调用 <code>&lt;Title/&gt;</code>组件的时候需要提供一个 <code>text</code>属性，除了在组件调用的时候提供 <code>text</code>属性之外，还应该在<code>propsType</code>中定义 <code>text</code>的类型检查，这一步很少有人写，我也没怎么写过，但是在多人协作的情况下显得就比较重要了，在多人协作情况下，如果给了错误的类型属性会导致直接抛出错误，这里还有一个<code>defaultProps</code>这是另外一个比较有用的，可以用它来设置默认的<code>props</code>的值，当调用组件的时候忘了传递相关属性，那么这个默认值显得就比较有用了(学习了)。</p>
<p>在 React 中没有严格的限制 props 传递的内容，这使得我们可以做一些有意思的事情<code>将一个组件作为参数传递</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SomethingElse</span>(<span class="params">&#123; answer &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>The answer is &#123;answer&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Answer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>42<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later somewhere in our application</span></span><br><span class="line">&lt;<span class="title class_">SomethingElse</span> answer=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Answer</span> /&gt;</span></span>&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<p>React 还有一个 <code>props.children</code> 属性，它代表可以访问父组件传递的子组件，例如这样</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Title</span>(<span class="params">&#123; text, children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;text&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/*这里可以拿到父组件传递下来的子组件span */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Title</span> <span class="attr">text</span>=<span class="string">&quot;Hello React&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>community<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<p>React 里面最明显的输出就是显示一个 <code>HTML</code>，在视觉上，这也是我们想得到的，但是 <code>props</code>可能是任何东西，一个函数、一个字符串、一个数组、等等等等</p>
<p>在下面例子中，组件接受一个回调函数，将 <code>input</code>的输入通过回调函数输出出去，传递给 <code>App</code>组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NameField</span>(<span class="params">&#123; valueUpdated &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> valueUpdated(event.target.value)&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NameField</span> <span class="attr">valueUpdated</span>=<span class="string">&#123;name</span> =&gt;</span> this.setState(&#123; name &#125;)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        Name: &#123;this.state.name&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中，经常需要一个逻辑入口点，在<code>React</code>中带有一些方便便捷的<code>声明周期方法</code>，可以在不同的时间做一些不同的事情，例如可以在生命周期中触发请求，获得数据资源。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResultsPage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 触发请求获得数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">getResults</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">results</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">results</span>=<span class="string">&#123;this.props.results&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">LoadingScreen</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将每个 React 组件视为一个黑盒，它有自己的输入输出和声明周期，将由开发者来组成这些盒子，这也是 React 提供的诸多优势之一，易于抽象和撰写。</p>
<h1>事件处理</h1>
<p>React 为事件处理提供了一系列属性，该解决方案与标准 DOM 中使用的解决方案几乎相同，但是也有一些差异，比如使用驼峰写法来添加一个事件，但是总体来说还是非常相似的。(这些所有的驼峰写法的事件，都是经过 React 包装的，在这些事件里面调用 this.setState 都是异步的，就是多次的 setState 都会被集中执行)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">theLogoIsClicked</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="string">&#x27;Clicked&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Logo</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">theLogoIsClicked</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> theInputIsChanged(event.target.value) &#125; /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样通常我们在包含事件的元素组件中处理事件，就像下面那样，有一个点击事件，每次点击都是运行相同的函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switcher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._handleButtonClick&#125;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在JavaScript中没有私有方法这一说，所以有些喜欢加一个下划线来表明方法是私有的，但是在函数名中加下划线也可能过不去eslint代码检查</span></span><br><span class="line">  <span class="title function_">_handleButtonClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Button is clicked&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，<code>_handleButtonClick</code>是一个函数，那么函数中的<code>this</code>指向哪里？严格模式下是<code>undefined</code>非严格模式下函数内部的<code>this</code>指向<code>window</code>对象，所以要在函数内部使用<code>this</code>需要做点额外的事情具体代码如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方案使用 bind</span></span><br><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">_handleButtonClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)&#125;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>但是<code>bind</code>之后每一次点击都会重新生成一个新的函数，更好的方法是在构造函数中绑定，这样只会生成一次</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switcher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;React in patterns&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// 在构造函数中进行 bind</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_buttonClick</span> = <span class="variable language_">this</span>.<span class="property">_handleButtonClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._buttonClick&#125;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_handleButtonClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Button is clicked inside <span class="subst">$&#123;<span class="variable language_">this</span>.state.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，又会有另外一个问题，如果有很多事件函数，难道一个一个的在构造函数里面<code>bind</code>？那么可以使用下面这种提案阶段语法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switcher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;React in patterns&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._buttonClick&#125;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _handleButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Button is clicked inside <span class="subst">$&#123;<span class="variable language_">this</span>.state.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写 <code>函数名 = () =&gt; &#123;&#125;</code> 这是一种提案阶段语法，但是已经在 <code>Facebook</code>内部大量使用，<code>Facebook</code>承诺如果将来这种语法没能称为标准(板上钉钉会上标准，除非发生灵异事件)，那么会由<code>Facebook</code>提供 babel 插件让开发者可以继续使用。</p>
<h1>组合</h1>
<p>React 最大的好处之一就是组合性，举个简单例子，假设有一个程序，有三个 React 组件，<code>App</code> 嵌套 <code>Header</code> 嵌套 <code>Navigation</code>组件</p>
<p>那么组合这些组件的简单方法就是在合适的地方引用它们</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./Header.jsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Navigation</span> <span class="keyword">from</span> <span class="string">&quot;./Navigation.jsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navigation</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Navigation.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Navigation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照这种方法进行组合，会有几个问题</p>
<ol>
<li>可能会让别人误认为 <code>App</code> 组件实现了所有功能，没有其他组建了。</li>
<li>这样写代码很难测试，加入每个组件都有一部分业务逻辑，为了分别测试他们，但是由于这个组件本身引用了另一个组件，这样嵌套的模式，让测试极为繁重。</li>
</ol>
<h2 id="使用-React-的-children-API">使用 React 的 children API</h2>
<p>在 React 中，有一个很方便的 <code>children</code>API，通过它可以直接从 props 中读取父组件给他的子组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navigation</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">header</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写组件可以很方便的测试<code>Header</code>组件，将<code>Header</code>组件和其他组件隔离开来，不依赖任何其他组件。</p>
<h2 id="传递一个子组件作为-Porps">传递一个子组件作为 Porps</h2>
<p>每个 React 组件都会收到 props，对 props 是什么类型，React 并没有任何严格的规定，所以可以让我们传递组件作为 props</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Title</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello there!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Header</span> = <span class="keyword">function</span>(<span class="params">&#123; title, children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;title&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&#123;</span>&lt;<span class="attr">Title</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 给title属性传递一个组件作为属性 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navigation</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给一个属性传递一个组件作为属性值，这种技术非常好用，考虑一个情况，有一个组件可以被多次复用，但是每个引用该组件的地方都需要做一点变化，那么将这个变化的部分写成一个属性，属性接受一个组件作为值。就可以很好的进行复用了。</p>
<h1>高阶组件</h1>
<p>长期一来，高阶组件作为增强 React 组件最流行的方式，运作方式看起来非常像装饰器(关于装饰器，Create-react-app 中为什么不支持，在文档中官方表示说装饰器还没有上标准，而且 babel 也没有正式实现，意思就是还在试验阶段，所以最终装饰器会是什么样子，还不确定，以至于 Facebook 官方并没有采用装饰器，而且装饰器没有办法提供模拟脚本，所以一旦最终的行为与现在不一致，他们将没有办法为用户提供过度。以至于一直不支持)</p>
<p>在技术方面，高阶组件通常接受我们的原始组件，然后返回增强后的函数或者组件，最小例子如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 定义一个函数，函数接受一个组件作为参数，并且返回一个添加了 props 属性的组件。</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">enhanceComponent</span> = <span class="title class_">Component</span> =&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Enhance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">OriginalTitle</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">EnhancedTitle</span> = <span class="title function_">enhanceComponent</span>(<span class="title class_">OriginalTitle</span>);</span><br><span class="line"><span class="comment">// 1. 定义一个普通的 App 组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EnhancedTitle</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高阶组件做的第一件事，就是渲染初始组件，代理传递<code>props</code> 给它是一种很好的做法，这样我们将保留原始组件的输入，这就是这种模式的第一大优势—因为我们控制组件的输入，所以我们可能会发送组件通常无法访问的内容，假设我们有一个<code>OriginalTitle</code>需要的配置设置</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&quot;path/to/configuration&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">enhanceComponent</span> = <span class="title class_">Component</span> =&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Enhance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">title</span>=<span class="string">&#123;config.appTitle&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">OriginalTitle</span> = (<span class="params">&#123; title &#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">EnhancedTitle</span> = <span class="title function_">enhanceComponent</span>(<span class="title class_">OriginalTitle</span>);</span><br></pre></td></tr></table></figure>
<p>这个高阶组件，将 <code>OriginalTitle</code>组件需要接受一个<code>title</code>属性的细节，放在了高阶函数内部实现的，外部也不知道<code>OriginalTitle</code>组件的 <code>title</code>属性值来自 <code>config.appTitle</code> 对象中，这是一种代码隔离，有助于组件的测试，因为可以轻松创建模拟</p>
<p>这种模式的另外一个特点，是可以让我们有一个很好的缓冲区来添加新的逻辑，例如，如果将<code>OriginalTitle</code>组件的某个属性值需要从服务器中获取，那么就可以使用高阶函数，并且在生命周期中进行请求</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 定义一个函数，函数接受一个参数，返回一个 React 组件，并且在组件生命周期内进行请求，然后更新到 state里面</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">enhanceComponent</span> = <span class="title class_">Component</span> =&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Enhance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">remoteTitle</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">fetchRemoteData</span>(<span class="string">&quot;path/to/endpoint&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">remoteTitle</span>: data.<span class="property">title</span> &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面进行渲染，当 state 被更新，组件就会重新渲染，这样就传递给了参数组件里面了</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">title</span>=<span class="string">&#123;config.appTitle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">remoteTitle</span>=<span class="string">&#123;this.state.remoteTitle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个普通的函数组件</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">OriginalTitle</span> = (<span class="params">&#123; title, remoteTitle &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;title&#125;</span></span><br><span class="line"><span class="language-xml">    &#123;remoteTitle&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用高阶函数并将上面的组件传做参数</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">EnhancedTitle</span> = <span class="title function_">enhanceComponent</span>(<span class="title class_">OriginalTitle</span>);</span><br></pre></td></tr></table></figure>
<p>这样，<code>OriginalTitle</code> 组件将会直到自己有两个属性，但是不用关系数据从哪里来</p>
<h2 id="render-props">render props</h2>
<p>而最近，React 社区开始流行一种新的方案， <code>render props</code>，在上面的例子中 <code>children</code>是一个 React 的组件，然而，<code>render props</code>中传递的是 <code>jsx表达式</code>，举个例子</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserName</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;children.lastName&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span>,&#123;children.firstName&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Krasimir&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Tsonev&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">UserName</span>&gt;</span>&#123;user&#125;<span class="tag">&lt;/<span class="name">UserName</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个有点意思，以前从来没这么写过，有点意思。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个组件并且遍历 todos 数组，调用 children 函数返回要渲染的 带b标签的 或者不带 标签的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params">&#123; todos, children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;main-section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;todo-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;todos.map((todo, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span>&#123;children(todo)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// App组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 定义一个数组</span></span><br><span class="line">  <span class="keyword">const</span> todos = [</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Write tests&quot;</span>, <span class="attr">status</span>: <span class="string">&quot;done&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Sent report&quot;</span>, <span class="attr">status</span>: <span class="string">&quot;progress&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Answer emails&quot;</span>, <span class="attr">status</span>: <span class="string">&quot;done&quot;</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 定义一个函数，返回布尔值</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isCompleted</span> = todo =&gt; todo.<span class="property">status</span> === <span class="string">&quot;done&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 调用 TodoList 组件，并且传一个 函数作为 children</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">todos</span>=<span class="string">&#123;todos&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;todo =&gt; (isCompleted(todo) ? <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;todo.label&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span> : todo.label)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">TodoList</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>慢慢看一下还是可以看懂的，写这样的代码有点抽象了</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params">&#123; todos, render &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;main-section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;todo-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;todos.map((todo, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span>&#123;render(todo)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">TodoList</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">todos</span>=<span class="string">&#123;todos&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">render</span>=<span class="string">&#123;todo</span> =&gt;</span> (isCompleted(todo) ? <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;todo.label&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span> : todo.label)&#125;</span></span><br><span class="line"><span class="language-xml">  /&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这是另外一种，通过定义一个 render 属性，值是一个函数，并且在 TodoList 组件内部调用 render 传的函数实现渲染，这种模式比上面哪个可读性高多了</p>
<p>通过组合，我们可以做一些好玩的事情比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProvider</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="comment">// 上面定义 date 为 null ，下面定义一个定时器 五秒之后更新 state</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">data</span>: <span class="string">&quot;Hey there!&quot;</span> &#125;), <span class="number">5000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 判断 date 是否为空，如果为空则不渲染</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span> === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 不为空则调用 props 的 render 函数并且传入参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;this.props.render(this.state.data)&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里调用并传入 render 属性，值为一个函数接受一个参数 返回一个标签（这个参数好像没什么意义</span></span><br><span class="line">&lt;<span class="title class_">DataProvider</span> render=&#123;<span class="function"><span class="params">data</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The data is here!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<h1>受控组件和非受控组件</h1>
<p>受控组件和非受控组件常用语用户输入，例如 下面就是一个 受控组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给input 组件传入 value 属性值为 state</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码确实是一个受控组件，但是用户无法更改<code>input</code>的值，因为的值指定的是一个固定的<code>state</code>这个<code>state</code>并不会更新永远都是<code>hello</code>，为了使值可以发生变化，需要添加<code>onChange</code>事件来更新和处理用户输入</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this._change&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">value</span>: e.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样添加了一个 <code>onChange</code>事件 并且指向 <code>_handleInputChange</code>函数，并且更新 state 刷新 UI 更新 input 的 value</p>
<p>##非受控组件</p>
<p>另一种是非受控组件，一般用于用户输入的值不重要不需要，只需要提供 <code>input</code>的 <code>defaultValue</code>属性即可，之后由浏览器保存用户输入值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">defaultValue</span>=<span class="string">&#123;this.state.value&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们无法获取用户输入，这个组件的值更新没有更新我们都无法得知，也不知道用户输入了什么，为了直到用户输入了什么我们必须使用<code>refs</code>来获取真实<code>DOM</code>读取用户输入。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">defaultValue</span>=<span class="string">&#123;this.state.value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;this._change&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> (this.input = input)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _handleInputChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，就不做过多解释。尽量不要在 React 中使用非受控模式</p>
<h1>展示组件和容器组件</h1>
<p>展示组件和容器组件也被称为，木偶组件和智能组件，这些概念对初学者很不友好，在初学者比较常见的一个问题就是我的数据应该放在哪里，如果进行通信，而这个问题的答案往往是不同统一的，只有经过大量的练习拥有了充足的经验之后，才可能有答案，但是对于这种问题是有一个被广泛使用的模式的，有助于组织基于 React 的应用程序，那就是将组件分解为 <code>展示组件</code>和<code>容器组件</code></p>
<p>从一个简单的例子开始说明，然后将组件分解为<code>展示组件</code>和<code>容器组件</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">time</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">time</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="variable language_">this</span>.<span class="title function_">_formatTime</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; time.hours &#125; : &#123; time.minutes &#125; : &#123; time.seconds &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_interval</span> = <span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">_update</span>, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">_interval</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_formatTime</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> [ hours, minutes, seconds ] = [</span><br><span class="line">      time.<span class="title function_">getHours</span>(),</span><br><span class="line">      time.<span class="title function_">getMinutes</span>(),</span><br><span class="line">      time.<span class="title function_">getSeconds</span>()</span><br><span class="line">    ].<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + num : num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; hours, minutes, seconds &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>.<span class="title function_">getTime</span>() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">time</span>=<span class="string">&#123;</span> <span class="attr">new</span> <span class="attr">Date</span>() &#125;/&gt;</span></span>, ...);</span><br></pre></td></tr></table></figure>
<p>在例子中，显示出档期内的时间值，通过<code>setInterval</code>每秒更新状态，而且组件会被重新渲染，使它看起来更像一个时钟</p>
<h2 id="问题">问题</h2>
<p>在这个组件中我们做了很多件事情，使它看起来很臃肿，不方便维护</p>
<ul>
<li>组件会自己改变自身的状态，改变组件内部的 <code>time</code>可能并不是一个好的主意，因为只有计时器才知道当前值，如果系统的另一部分依赖于这些数据，则很难分享</li>
<li>_formatTime 函数其实在做两件事，首先从日期中提取所需的信息，并且确保这些值始终以两位数字表示，如果它不提取函数的一部分，那么就没什么问题，但是正是由于它引用了另外的函数，那么他就会强行绑定在当前环境</li>
</ul>
<h3 id="提取容器组件">提取容器组件</h3>
<p>容器组件了解数据，知道数据来自哪里，知道业务逻辑的细节，接受信息并将其格式化，使其容易被展示组件使用，大佬们经常使用<code>class</code>来创建容器，因为可以提供一个缓冲区间，可以在其中插入自定义逻辑</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clock/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Clock</span> <span class="keyword">from</span> <span class="string">&quot;./Clock.jsx&quot;</span>; <span class="comment">// &lt;-- that&#x27;s the presentational component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ClockContainer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">time</span>: props.<span class="property">time</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> &#123;<span class="attr">...this._extract</span>(<span class="attr">this.state.time</span>)&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_interval</span> = <span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">_update</span>, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">_interval</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_extract</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">hours</span>: time.<span class="title function_">getHours</span>(),</span><br><span class="line">      <span class="attr">minutes</span>: time.<span class="title function_">getMinutes</span>(),</span><br><span class="line">      <span class="attr">seconds</span>: time.<span class="title function_">getSeconds</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateTime = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>.<span class="title function_">getTime</span>() + <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ClockContainer</code>组件初始一个<code>state</code> 并且在 <code>componentDidMount</code>生命周期中调用<code>setInterval</code>每秒更新<code>state</code>，并且最后将毫秒数传给<code>Clock</code>组件</p>
<h3 id="展示组件">展示组件</h3>
<p>展示组件只关心如何展现 UI 部分，这些组件不需要逻辑函数，也没有依赖，通常时限为<code>无状态组件</code>，表示他们内部不保留任何状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Clock</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> [hours, minutes, seconds] = [</span><br><span class="line">    props.<span class="property">hours</span>,</span><br><span class="line">    props.<span class="property">minutes</span>,</span><br><span class="line">    props.<span class="property">seconds</span></span><br><span class="line">  ].<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> (num &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + num : num));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;hours&#125; : &#123;minutes&#125; : &#123;seconds&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据全靠<code>父组件传递</code>，本身只负责渲染 UI 部分</p>
<h3 id="这样做的好处">这样做的好处</h3>
<p>这样做有什么好处，好处就是可以提高组件的可重用性，减少组件之间的耦合状态，将<code>逻辑</code>与<code>UI</code>分离开来，互相之间没有强耦合关系，逻辑不管 UI，同理 UI 也不关心逻辑实现。</p>
<h1>单向数据流</h1>
<p>单向数据流是一种和 React 十分契合的一种模式，围绕这种模式，数据是单向的，即组件不会修改接收到的数据，只会监听这些数据变化，从而得到新的值，但是不会修改实际的数据，这个更新发生在另一个地方的另一个机制，并且该组件将会被重新渲染，并赋予新的值。</p>
<p>举个例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switcher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">flag</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_onButtonClick</span> = <span class="function"><span class="params">e</span> =&gt;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">flag</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">flag</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._onButtonClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.flag ? &quot;lights on&quot; : &quot;lights off&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and we render it</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Switcher</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时只有<code>Switcher</code>组件内部持有数据，也就是说<code>Switcher</code>是唯一知道<code>flag</code>的地方</p>
<p>那么接下来将这个 <code>flag</code>传递给别的对象：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Store</span> = &#123;</span><br><span class="line">  <span class="attr">_flag</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_flag</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_flag</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switcher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">flag</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_onButtonClick</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">flag</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">flag</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">onChange</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">flag</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this._onButtonClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.flag ? &quot;lights on&quot; : &quot;lights off&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Switcher</span> <span class="attr">onChange</span>=<span class="string">&#123;Store.set&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过<code>Switcher</code>的<code>button的onClic</code>事件触发修改 flag，并且通过 <code>props</code>传下来的 <code>onChange</code>属性的值是一个函数，调用这个函数成功修改 <code>Store</code>对象的值。</p>
<p>思考一个问题，如果<code>Store</code>对象，被其他组件修改了，这里就发生了数据不同意 <code>Store</code>已经被更改了，<code>Switcher</code>组件内部的<code>flag</code>并没有更改，这就导致了数据不统一。</p>
<p>而单项数据流就是为了解决这个问题，他消除了状态存于多处，而导致的数据不统一，为了实现这一点，我们稍微对<code>Store</code>稍微进行一下调整</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Store</span> = &#123;</span><br><span class="line">  <span class="comment">// 通知队列</span></span><br><span class="line">  <span class="attr">_handlers</span>: [],</span><br><span class="line">  <span class="comment">// flag的值</span></span><br><span class="line">  <span class="attr">_flag</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 将通知对象添加进队列以便数据更改进行通知</span></span><br><span class="line">  <span class="attr">subscribe</span>: <span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_handlers</span>.<span class="title function_">push</span>(handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_flag</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> <span class="title function_">handler</span>(value));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_flag</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的订阅通知模式，然后更新 App 组件，以便每次 Store 更改的时候重新渲染它：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 定义初始 state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="title class_">Store</span>.<span class="title function_">get</span>() &#125;;</span><br><span class="line">    <span class="comment">// 将 App 的 setState 添加到带通知队列内Store._handlers 从 [] 变为了 [(value) =&gt; &#123;this.setState(&#123;value&#125;)&#125;]，等数据发生变化的时候执行队列函数，就可以更新 App 的 state 从而引发重新渲染</span></span><br><span class="line">    <span class="title class_">Store</span>.<span class="title function_">subscribe</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; value &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switcher</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;Store.set.bind(Store)&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于存在了这种变化，<code>Switcher</code>变得非常简单，因此可以将<code>Switcher</code>写成一个无状态组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Switcher</span>(<span class="params">&#123; value, onChange &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> onChange(!value)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;value ? &quot;lights on&quot; : &quot;lights off&quot;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Switcher</span> value=&#123;<span class="title class_">Store</span>.<span class="title function_">get</span>()&#125; onChange=&#123;<span class="title class_">Store</span>.<span class="property">set</span>&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<p>这种单向的数据模式，使得开发变得更加容易，无需担心数据的不统一，希望可以通过这个例子了解一下单向数据模式。</p>
<h1>Flux</h1>
<p>作者迷恋于简化代码，但是并不是说越小越好，因为减少代码并不意味着更加易用，同时作者相信软件行业的很大一部分问题来自不必要的复杂性，复杂性是自己抽象的结果，程序员喜欢抽象，喜欢把东西放在黑盒内，并期望这些盒子能够一起工作，</p>
<p>Flux 是构建用户界面体系的设计模式，它是由 Facebook 在 F8 会议上退出的，从那之后，很多公司采纳了这个想法，这事故是构建前端应用程序的一个很好的模式，Flux 经常和 React 一起使用，这种模式简单而灵活，这种模式有助于更快的创建应用程序，同时保持代码组织良好</p>
<p>流程如下</p>
<p>Views —&gt; 触发 action —&gt; 通过 dispatch —&gt; 更新 Stores —&gt; 而 Stores 的更新会引起 View 重新渲染</p>
<p>这种模式中的最主要的部分是 dispatch ，它充当系统中所有实践的中心， 它的工作是接 action 并且传递给 Store，并通过内部状态/数据做出反应，这种变化触发了对 React 组件的重新渲染</p>
<p>这些 action 是从 View 或者其他部分进入 dispatch ，例如 HTTP 请求结束收到结果会触发一个 action ，说明请求成功。</p>
<h2 id="dispatcher">dispatcher</h2>
<p>在大多情况下，都需要一个 dispatcher ，它将作为与其他部分之间的沟通部分，dispatcher 需要知道两件事情，action 和 Store，并且将这些 action 转发给 Store</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Dispatcher</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">_stores</span>: [],</span><br><span class="line">    <span class="attr">register</span>: <span class="keyword">function</span>(<span class="params">store</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="keyword">function</span>(<span class="params">action</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">          entry.<span class="property">store</span>.<span class="title function_">update</span>(action);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里向 Store 中存在一个 <code>update</code>方法，如果这个方法不存在则抛出一个错误</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">register</span>: <span class="keyword">function</span> (<span class="params">store</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.<span class="property">update</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;你需要为 Store 提供一个拥有 `update` 方法.&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmmmmm 下面字谷歌翻译也看不懂。。。。</p>
<h2 id="更新-View-和-Store">更新 View 和 Store</h2>
<p>接下来合乎逻辑的步骤是<code>View</code> 链接到 <code>Store</code>，以便在 <code>Store</code>放生变化的时候 <code>View</code>可以进行重新渲染</p>
<h3 id="使用-Flux-辅助函数">使用 Flux 辅助函数</h3>
<p>这里可以使用 <code>Flux</code>提供的一个辅助函数来完成链接功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Framework</span>.<span class="title function_">attachToStore</span>(view, store);</span><br></pre></td></tr></table></figure>
<p>通过辅助函数来链接<code>view</code>和<code>store</code></p>
<p>但是作者不喜欢这种直接调用赋值函数的方法，所以下面将介绍如果自己实现这个方法</p>
<p>###使用 mixin</p>
<p>使用 React 的 mixin 进行构建(mixin 官方已经弃用了)</p>
<p>官方说明：</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>ES6 在没有任何混合支持的情况下发布。因此，当您使用 ES6 类的 React 时，不支持 mixin。</p>
<p><strong>我们在使用 mixins 的代码库中也发现了很多问题，并且不建议在新代码中使用它们。</strong></p>
<p>本部分仅供参考</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">View</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [<span class="title class_">Framework</span>.<span class="title function_">attachToStore</span>(store)]</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是定义现有 React 组件行为的好方法(createClass 是使用 es5 语法书写 React 的方法)</p>
<p>emmmm 。。。作者不喜欢 mixin 因为它用不可预测的方式修改组件，所以放弃了这个选项</p>
<h3 id="使用-context">使用 context</h3>
<p>那么 mixin 不能用那就只能使用另一个可行的技术是 React 的 context API，这是一种可以穿透组件传递状态的方法，而不需要在每个组件中层层传递，Facebook 在数据必须深入嵌套组件的情况下建议使用 context</p>
<h3 id="高阶组件概念">高阶组件概念</h3>
<p>高阶组件借鉴了 <a target="_blank" rel="noopener" href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775">introduced</a> 代码片段(这个地址好像要科学上网)作者 Sebastian,它是关于创造一个返回包装过的组件，做这件事它将有机会添加属性和引入其他逻辑，例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是个高阶函数不用讲了吧</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">attachToStore</span>(<span class="params">Component, store, consumer</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 es5 语法创建一个 react 的 class</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Wrapper</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">    <span class="comment">// 定义初始 state 下面的我也不太懂。。抱歉</span></span><br><span class="line">    <span class="title function_">getInitialState</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">consumer</span>(<span class="variable language_">this</span>.<span class="property">props</span>, store);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      store.<span class="title function_">onChangeEvent</span>(<span class="variable language_">this</span>.<span class="property">_handleStoreChange</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      store.<span class="title function_">offChangeEvent</span>(<span class="variable language_">this</span>.<span class="property">_handleStoreChange</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">_handleStoreChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isMounted</span>()) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="title function_">consumer</span>(<span class="variable language_">this</span>.<span class="property">props</span>, store));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Wrapper</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想将<code>Store</code>附加到 <code>store</code>，同时传入一个<code>consumer</code>函数说明应该提取哪些<code>Store</code>的状态并且分发到<code>view</code>，上述功能的简单使用可以是</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyView</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ProfilePage</span> = <span class="title function_">connectToStores</span>(<span class="title class_">MyView</span>, store, <span class="function">(<span class="params">props, store</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">data</span>: store.<span class="title function_">get</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>真是巧妙的代码，反正我写不出来，我理解起来都需要一会，真是巧妙。</p>
<p>这是一个有趣的模式，因为它改变了职责，从<code>Store</code>中获取数据的<code>view</code>，而不是从<code>Store</code>中推送数据到<code>view</code>，当然这也有他的缺点，这种方法的缺点就是还需要一个包装组件参与其中</p>
<h3 id="作者的选择">作者的选择</h3>
<p>上面的最后一个选项是高阶组件，它非常接近作者正在探索的内容</p>
<p>到目前为止仅在该<code>register</code>方法中与<code>Store</code>进行交互</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">register</span>: <span class="keyword">function</span> (<span class="params">store</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.<span class="property">update</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;你应该为store提供一个 `update` 方法.&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>register</code> 保持对<code>dispatcher</code>内的<code>store</code>的引用，但是，<code>register</code>他可能会返回一个用户接受的<code>subscriber</code></p>
<p>决定将整个<code>store</code>放在<code>consumer</code>里面，而不是在<code>store</code>中保存数据，就像高阶组件一样，View 应该使用<code>stroe</code>的<code>getter</code>方法来说明他需要什么，这使得<code>store</code>非常简单</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register 接受一个 Store对象，对象需要有一个 update方法如果不存在就抛出异常</span></span><br><span class="line"><span class="attr">register</span>: <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用箭头函数绑定this</span></span><br><span class="line">  <span class="keyword">if</span> (!store || !store.<span class="property">update</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;你应该为store 提供一个 `update` 方法.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> consumers = []; <span class="comment">// 通知列表</span></span><br><span class="line">    <span class="keyword">var</span> subscribe = <span class="keyword">function</span>(<span class="params">consumer</span>) &#123;</span><br><span class="line">      <span class="comment">// 待通知对象</span></span><br><span class="line">      consumers.<span class="title function_">push</span>(consumer); <span class="comment">// 添加到队列</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store &#125;);</span><br><span class="line">    保存store;</span><br><span class="line">    <span class="keyword">return</span> subscribe; <span class="comment">// 返回添加通知函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据原则，Store 会根据行为改变状态，在<code>update</code>方法中发送<code>action</code>，也可以发送一个<code>change</code>函数，调用这个函数触发观察者模式。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">register</span>: <span class="keyword">function</span> (<span class="params">store</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!store || !store.<span class="property">update</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">      <span class="string">&#x27;You should provide a store that has an `update` method.&#x27;</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> consumers = [];</span><br><span class="line">    <span class="keyword">var</span> change = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      consumers.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">l</span>) &#123;</span><br><span class="line">        <span class="title function_">l</span>(store);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> subscribe = <span class="keyword">function</span> (<span class="params">consumer</span>) &#123;</span><br><span class="line">      consumers.<span class="title function_">push</span>(consumer);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store, <span class="attr">change</span>: change &#125;);</span><br><span class="line">    <span class="keyword">return</span> subscribe;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">dispatch</span>: <span class="keyword">function</span> (<span class="params">action</span>) &#123; <span class="comment">// dispatch 函数接受一个参数action</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果store不为空</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">entry</span>) &#123;<span class="comment">// 调用遍历函数给store中每个对象添加一个update方法用来发送action和触发观察者模式函数</span></span><br><span class="line">      entry.<span class="property">store</span>.<span class="title function_">update</span>(action, entry.<span class="property">change</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常用的方法就是使用<code>Store</code>的初始状态渲染<code>View</code>,这意味着至少需要一次初始化，可以通过下面的<code>subscribe</code>方法完成</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscribe = <span class="keyword">function</span>(<span class="params">consumer, noInit</span>) &#123;</span><br><span class="line">  consumers.<span class="title function_">push</span>(consumer);</span><br><span class="line">  !noInit ? <span class="title function_">consumer</span>(store) : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看不太懂，有点绕</p>
<p>下面是最终版本</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">Dispatcher</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">_stores</span>: [], <span class="comment">// stores 对象</span></span><br><span class="line">    <span class="attr">register</span>: <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个函数接受原始 store 对象作为参数，并且判断其中有没有update方法</span></span><br><span class="line">      <span class="keyword">if</span> (!store || !store.<span class="property">update</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">&quot;You should provide a store that has an `update` method&quot;</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumers = []; <span class="comment">// 待通知队列</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 给每个待通知对象都传入一个store</span></span><br><span class="line">          consumers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">l</span>) &#123;</span><br><span class="line">            <span class="title function_">l</span>(store);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">subscribe</span> = (<span class="params">consumer, noInit</span>) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 订阅对象接受一个待通知函数和是否进行初始化布尔值</span></span><br><span class="line">          consumers.<span class="title function_">push</span>(consumer);</span><br><span class="line">          !noInit ? <span class="title function_">consumer</span>(store) : <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store, <span class="attr">change</span>: change &#125;); <span class="comment">// 不太懂</span></span><br><span class="line">        <span class="keyword">return</span> subscribe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// dispatch</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断Store是否为空</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">          <span class="comment">// 调用被通知对象函数通知更新</span></span><br><span class="line">          entry.<span class="property">store</span>.<span class="title function_">update</span>(action, entry.<span class="property">change</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="action">action</h3>
<p>action 定义为右两个属性，<code>type</code>，<code>payload</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;USER_LOGIN_REQUEST&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;...&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>action</code> 包含了两个对象分别是<code>type</code>和<code>payload</code>，在一些情况下<code>payload</code>可以是空的</p>
<p>创建一个创建一个函数，用来构造 <code>action</code>对象，例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createAction = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Please, provide action&#x27;s type.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> dispatcher.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: type,</span><br><span class="line">        <span class="attr">payload</span>: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用两次，第一次调用传入<code>type</code>第二次调用传入<code>payload</code></p>
<p>这个函数有几个好处</p>
<ul>
<li>不再需要记住<code>action</code>的具体类型，仅仅需要传入一个<code>type</code></li>
<li>不在需要显式的调用<code>dispatch</code>函数</li>
<li>不必要亲自处理每个细节，而是将过程封装为一个函数，这个函数会描述整个过程</li>
</ul>
<p>这个也影响到了接下来流行的 redux</p>
<p>最终部分代码</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createSubscriber = <span class="keyword">function</span>(<span class="params">store</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">register</span>(store);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Dispatcher</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">_stores</span>: [],</span><br><span class="line">    <span class="attr">register</span>: <span class="keyword">function</span>(<span class="params">store</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!store || !store.<span class="property">update</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">&quot;You should provide a store that has an `update` method&quot;</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumers = [];</span><br><span class="line">        <span class="keyword">var</span> change = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          consumers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">l</span>) &#123;</span><br><span class="line">            <span class="title function_">l</span>(store);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> subscribe = <span class="keyword">function</span>(<span class="params">consumer, noInit</span>) &#123;</span><br><span class="line">          consumers.<span class="title function_">push</span>(consumer);</span><br><span class="line">          !noInit ? <span class="title function_">consumer</span>(store) : <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">push</span>(&#123; <span class="attr">store</span>: store, <span class="attr">change</span>: change &#125;);</span><br><span class="line">        <span class="keyword">return</span> subscribe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="keyword">function</span>(<span class="params">action</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_stores</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">          entry.<span class="property">store</span>.<span class="title function_">update</span>(action, entry.<span class="property">change</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">create</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dispatcher = <span class="title class_">Dispatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">createAction</span>: <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Please, provide action&#x27;s type.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatcher.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">              <span class="attr">type</span>: type,</span><br><span class="line">              <span class="attr">payload</span>: payload</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">createSubscriber</span>: <span class="keyword">function</span>(<span class="params">store</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatcher.<span class="title function_">register</span>(store);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个过程真的巧妙，厉害</p>
<h1>Redux</h1>
<p>redux 是一个状态管理库，在 <code>React</code>中管理全局数据，是<code>Flux</code>的进阶版</p>
<p>在<code>redux</code>中由<code>React</code>部分触发<code>action</code>，到达<code>Store</code>，最后由<code>reducer</code>更新<code>Store</code></p>
<p>和<code>Flux</code>最大的区别就是<code>Redux</code>只有一个<code>Store</code>，最后决定数据的是由<code>reducer</code>来决定的，<code>reducer</code>是一个纯函数，一旦<code>Store</code>接收到一个<code>action</code>就会挨个匹配<code>reducer</code>并且调用函数进行更新数据</p>
<p>这个理念非常线性，而且遵循<code>单向数据流</code>接下来介绍一些<code>redux</code>的工作模式</p>
<h2 id="Actions">Actions</h2>
<p>在<code>Redux</code>中的和<code>flux</code>类似，<code>action</code>都是一个具有<code>type</code>的对象，这个对象中的其他所有数据都和这个模式无关</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CHANGE_VISIBILITY</span> = <span class="string">&quot;CHANGE_VISIBILITY&quot;</span>; <span class="comment">// 常理中全大写的字符串是静态的固定的</span></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">CHANGE_VISIBILITY</span>,</span><br><span class="line">  <span class="attr">visible</span>: <span class="literal">false</span> <span class="comment">// 携带的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当需要<code>dispatch</code>一个<code>action</code>的时候，都必须要使用这个对象，但是一遍一遍抄太枯燥了，这就是为什么有<code>createAction</code>，这个<code>createAction</code>是一个函数，返回一个对象。</p>
<h2 id="Store">Store</h2>
<p>在<code>Redux</code>中，为我们提供了一个<code>createStore</code>函数用来创建<code>Store</code>使用方法如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="title function_">createStore</span>([reducer],[initial state],[enhancer])</span><br></pre></td></tr></table></figure>
<p>createStore 的第一个参数<code>reducer</code>是一个接受当前<code>action</code>并且返回新的状态的函数，第二个参数是<code>初始化状态</code>，这是一个非常方便定义初始状态的地方，第三个参数是<code>Redux</code>添加第三方中间件的，可以用来添加一些插件，比如日至打印，异步处理等中间件。</p>
<p>一旦创建<code>Store</code>之后，<code>Store</code>就有了四种方法，<code>getState</code>，<code>dispatch</code>，<code>subscribe</code>，和<code>replaceReducer</code>其中最重要的是<code>dispatch</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispath</span>(<span class="title function_">changeVisibility</span>(<span class="literal">false</span>));</span><br></pre></td></tr></table></figure>
<p>这里是使用<code>createAction</code>的地方，将这个函数的返回对象传递给<code>dispatch</code>方法，然后他会在应用程序中传递给<code>reducer</code>，在典型的<code>React</code>应用程序中，通常不会直接使用<code>getState</code>，<code>subscribe</code>因为有一个帮助函数(因为在 React 中有一个 react-redux 这个包提供了两个 API 帮助我们更好的使用 redux，而上面这两个函数是用在其他框架中使用 redux 提供的基础 API，用起来还是比较麻烦的)，将组件和状态链接到一起，而<code>replaceReducer</code>是一种先进的 API 它用来替换<code>reducer</code>函数，我没用过这个函数</p>
<h2 id="Reducer">Reducer</h2>
<p><code>reducer</code>可能是<code>Redux</code>中最为精妙的部分，<code>reducer</code>有两个特点非常重要：</p>
<ul>
<li>它必须是纯函数，意味着只要输入相同，那么输出一定相同。</li>
<li>它不应该有副作用，像访问全局变量，进行异步操作等</li>
</ul>
<p>下面是一个简单的计数器的<code>reducer</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接受另个参数，第一个参数是当前状态，第二个参数是action对象，其中必定包含了type属性，也可以附带其他的数据</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="variable constant_">ADD</span>) &#123;</span><br><span class="line">    <span class="comment">// 对比type 是否等一 “ADD”</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.<span class="property">value</span> + <span class="number">1</span> &#125;; <span class="comment">// 是则+1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="variable constant_">SUBTRACT</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.<span class="property">value</span> - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;; <span class="comment">// 如果type都不符则返回value：0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数没有副作用，而且每次都会返回一个全新的对象，根据之前的值进行累加或者减少</p>
<h2 id="连接到-React-组件">连接到 React 组件</h2>
<p>如果是在<code>React</code>中讨论<code>redux</code>那么必定包含<code>react-redux</code>模块，<code>react-redux</code>提供了两个重要 API 用来将 React 和 Redux 进行连接</p>
<ol>
<li>
<p><code>&lt;Provider/&gt;</code> 组件，他是一个组件，接受一个<code>Store</code>作为参数，并且通过<code>React</code>的 <code>context</code> API 穿透组件进行通信，举个例子</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> myStore <span class="keyword">from</span> <span class="string">&quot;自己写的store对象&quot;</span>;</span><br><span class="line"><span class="comment">// Provider 应作为最上级组件包裹整个 React 应用，保证他的所有子集都可以获得到传递的数据</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;myStore&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyApp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>connect</code> 函数，用于订阅<code>Redux</code>的<code>Store</code>并且用来更新 UI ，他是一个高阶组件，下面是它接受的参数</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">connect</span>([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]);</span><br></pre></td></tr></table></figure>
<p>mapStateToProps 参数是是一个函数，它会接受到当前的<code>state</code>作为参数，并且必须返回一个对象，这些对象会被以<code>props</code>的形式传递给组件，例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123;</span><br><span class="line">  <span class="attr">visible</span>: state.<span class="property">visible</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这样组件将会接收到一个 visible 的 props 他的值就是 store里面的 visible</span></span><br></pre></td></tr></table></figure>
<p>mapDispatchToProps 也是一个函数，但不是接受<code>state</code>而是接受<code>dispatch</code>作为参数，这里可以定义<code>dispatch action</code>props 的地方</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = dispatch =&gt; (&#123;</span><br><span class="line">  <span class="attr">changeVisibility</span>: <span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">changeVisibility</span>(value))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这样组件将会接受到一个 changeVisibility 函数的 props 运行这个函数并且传入一个参数就会dispatch一个action</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<p>后面最后两个参数用的比较少，可以去官方文档看。</p>
<h2 id="一个简单的计数器">一个简单的计数器</h2>
<p>来创建一个简单的应用来使用上面提到的 API</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/qxnl7wxylq">这里写了个在线的例子，可以跑起来的</a></p>
<h3 id="创建-action">创建 action</h3>
<p>对于作者而言，每个<code>Redux</code>都应该从构建<code>action</code>开始，并且定义我们向保留的状态，对于计数器而言，设计三个状态<code>ADD</code>增加，<code>subtract</code>减少，<code>change visibility</code>更改计数器数值</p>
<h3 id="Store-和-reducer">Store 和 reducer</h3>
<p>有些东西在前面没讲到，是说一个应用通常有很多个<code>reducer</code>，这样可以分开定义很多事情，而不必耦合在一起，这里的<code>Store</code>虽然只有一个，但是可以有很多属性，就是下面这种结构</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但是redux提供了组合函数将这些分片的reduce组合起来</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: reducer1,</span><br><span class="line">  <span class="attr">visible</span>: reducer2</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer);</span><br></pre></td></tr></table></figure>
<p>接下来定义<code>reducer</code>应该定义的<code>ADD</code>,<code>SUBRECT</code>并且计算出新的<code>counter</code>状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为比较少所以就用了if 如果多的话可以使用 swift 进行匹配</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="keyword">function</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="variable constant_">ADD</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.<span class="property">value</span> + <span class="number">1</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="variable constant_">SUBTRACT</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.<span class="property">value</span> - <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state || &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>Redux</code>初始化的时候，每个<code>reducer</code>会被至少触发一次，在第一次运行的时候<code>state</code>是<code>undefined</code>和<code>action</code>现在<code>&#123; type: &quot;@@redux/INIT&quot;&#125;</code>， 之后我们定义的<code>reducer</code>就会返回数据的初始值<code>&#123; value: 0 &#125;</code></p>
<p>之后的第三个也就是<code>CHANGE_VISIBILITY</code>也和上面的差不多</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visibilityReducer = <span class="keyword">function</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="variable constant_">CHANGE_VISIBILITY</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.<span class="property">visible</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样我们就有了两个<code>reducer</code>，就可以按照上面的方法将这两个<code>reducer</code>组合起来</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: counterReducer,</span><br><span class="line">  <span class="attr">visible</span>: visibilityReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="React-组件">React 组件</h3>
<p>首先处理计数器的用户界面</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Visibility</span>(<span class="params">&#123; changeVisibility &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> changeVisibility(true)&#125;&gt;Visible<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> changeVisibility(false)&#125;&gt;Hidden<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VisibilityConnected</span> = <span class="title function_">connect</span>(</span><br><span class="line">  <span class="literal">null</span>, <span class="comment">// 没有订阅任何的 Store 的属性</span></span><br><span class="line">  <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// 被映射到 props 的方法</span></span><br><span class="line">    <span class="attr">changeVisibility</span>: <span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">changeVisibility</span>(value))</span><br><span class="line">  &#125;)</span><br><span class="line">)(<span class="title class_">Visibility</span>); <span class="comment">// 高阶组件的用法</span></span><br></pre></td></tr></table></figure>
<p>第二个组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123; value, add, subtract &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Value: &#123;value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;subtract&#125;</span>&gt;</span>Subtract<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CounterConnected</span> = <span class="title function_">connect</span>(</span><br><span class="line">  <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// 订阅了</span></span><br><span class="line">    <span class="attr">value</span>: state.<span class="property">counter</span>.<span class="property">value</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">add</span>()),</span><br><span class="line">    <span class="attr">subtract</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">subtract</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">)(<span class="title class_">Counter</span>);</span><br></pre></td></tr></table></figure>
<p>最后的组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; visible &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">VisibilityConnected</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; visible &amp;&amp; <span class="tag">&lt;<span class="name">CounterConnected</span> /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AppConnected</span> = <span class="title function_">connect</span>(</span><br><span class="line">  <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">visible</span>: state.<span class="property">visible</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">)(<span class="title class_">App</span>);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/React/" rel="tag"># React</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/04/21/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Docker学习笔记">
                  <i class="fa fa-angle-left"></i> Docker学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/07/22/Immer%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="next" title="Immer源码学习">
                  Immer源码学习 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">H</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
